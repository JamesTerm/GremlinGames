<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: RakPeer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>RakPeer Class Reference</h1><!-- doxytag: class="RakPeer" --><!-- doxytag: inherits="RakPeerInterface" -->The main interface for network communications.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;RakPeer.h&gt;</code>
<p>
<p>Inheritance diagram for RakPeer:
<p><center><img src="classRakPeer.png" usemap="#RakPeer_map" border="0" alt=""></center>
<map name="RakPeer_map">
<area href="classRakPeerInterface.html" alt="RakPeerInterface" shape="rect" coords="60,0,170,24">
<area href="classRakClient.html" alt="RakClient" shape="rect" coords="0,112,110,136">
<area href="classRakServer.html" alt="RakServer" shape="rect" coords="120,112,230,136">
</map>
<a href="classRakPeer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff7ebc01fb71df027b1a065ff63ca8b4"></a><!-- doxytag: member="RakPeer::RakPeer" ref="ff7ebc01fb71df027b1a065ff63ca8b4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ff7ebc01fb71df027b1a065ff63ca8b4">RakPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="107b5d6bae255046e88fc5c96e991719"></a><!-- doxytag: member="RakPeer::~RakPeer" ref="107b5d6bae255046e88fc5c96e991719" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#107b5d6bae255046e88fc5c96e991719">~RakPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2c2a99cb2efb728fa814d41b2071617d">Initialize</a> (unsigned short maxConnections, unsigned short localPort, int _threadSleepTimer, const char *forceHostAddress=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the network threads, opens the listen port. You must call this before calling <a class="el" href="classRakPeer.html#80e98d77e4140079634ebb284c4168f8">Connect()</a>. Multiple calls while already active are ignored. To call this function again with different settings, you must first call <a class="el" href="classRakPeer.html#44dd4adfb061e1335cef84300f758b6a">Disconnect()</a>.  <a href="#2c2a99cb2efb728fa814d41b2071617d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#adcb268bdcd4751c304c8156c28eb66d">InitializeSecurity</a> (const char *pubKeyE, const char *pubKeyN, const char *privKeyP, const char *privKeyQ)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#bc9e3cd4ac407f23ce1ee99c94cabd88">DisableSecurity</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d2004ca40f0a88ca24f70196321d48c8">SetMaximumIncomingConnections</a> (unsigned short numberAllowed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5c413e010504007506d6be8bc27a2668">GetMaximumIncomingConnections</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c">SetIncomingPassword</a> (const char *passwordData, int passwordDataLength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3d16efedd2007d917e613a78f816baba">GetIncomingPassword</a> (char *passwordData, int *passwordDataLength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#80e98d77e4140079634ebb284c4168f8">Connect</a> (const char *host, unsigned short remotePort, char *passwordData, int passwordDataLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port. Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer. This is a non-blocking connection. You know the connection is successful when IsConnected() returns true or <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">Receive()</a> gets a message with the type identifier ID_CONNECTION_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen.  <a href="#80e98d77e4140079634ebb284c4168f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#44dd4adfb061e1335cef84300f758b6a">Disconnect</a> (unsigned int blockDuration, unsigned char orderingChannel=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops the network threads and closes all connections.  <a href="#44dd4adfb061e1335cef84300f758b6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#52ff3b23878d11d8b00473835d44b1f5">IsActive</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#0258deb9b3cdbc9c9c0eb39d61207798">GetConnectionList</a> (<a class="el" href="structPlayerID.html">PlayerID</a> *remoteSystems, unsigned short *numberOfSystems) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#97315733490a1f04c830d151d9dd53c0">Send</a> (const char *data, const int length, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5f38c85967d6e57e9516c52271adc292">Send</a> (<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">Receive</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f68f8d2766b45b6d951dfd62cf349a71">DeallocatePacket</a> (<a class="el" href="structPacket.html">Packet</a> *packet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23aa5e3e7f94cccd150392ff73233526"></a><!-- doxytag: member="RakPeer::GetMaximumNumberOfPeers" ref="23aa5e3e7f94cccd150392ff73233526" args="(void) const " -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#23aa5e3e7f94cccd150392ff73233526">GetMaximumNumberOfPeers</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of connections we are allowed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g1313637c90bc5bb393e976ae03c84d9d">RegisterAsRemoteProcedureCall</a> (char *uniqueID, void(*functionPointer)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#ge628eea0de67ee0cbed704e23e7dfcd0">RegisterClassMemberRPC</a> (char *uniqueID, void *functionPointer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gbb32f8917f372c81c03f4595c58cdde2">UnregisterAsRemoteProcedureCall</a> (char *uniqueID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g6e6833d5d0fdfe79e7a115a274e80acc">RPC</a> (char *uniqueID, const char *data, unsigned int bitLength, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast, bool shiftTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g9c29982e3c01ae34292547d08a31cdf7">RPC</a> (char *uniqueID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast, bool shiftTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#cc60e0732bd685a2f0216831e4cb43f3">CloseConnection</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> target, bool sendDisconnectionNotification, unsigned char orderingChannel=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#76f9b346240d1a4225bc9d85b5eb4c75">GetIndexFromPlayerID</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#661bc3f0d27aff4eaf7d3ca3136c47c7">GetPlayerIDFromIndex</a> (int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8f641435cc9a86c48ad5f105ed4e74ed">AddToBanList</a> (const char *IP, RakNetTime milliseconds=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d046c7809b8889ba708bc20881845e4d">RemoveFromBanList</a> (const char *IP)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d0f94bb0bf24d4bbe1df80b1f3bce9d"></a><!-- doxytag: member="RakPeer::ClearBanList" ref="3d0f94bb0bf24d4bbe1df80b1f3bce9d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3d0f94bb0bf24d4bbe1df80b1f3bce9d">ClearBanList</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows all previously banned IPs to connect. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e1ad09ea9ca5ea8bd4a00f78e22a5abc">IsBanned</a> (const char *IP)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#0dde31855b5dde9191d5debc283315de">Ping</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> target)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7b8fe9db232e77c48121ff42143d6c4c">Ping</a> (const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a857af87b64b9fe925b6664b010bf298">GetAveragePing</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#933e4c272dd6801e7025bb1fd38a43ba">GetLastPing</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#fe482086aeca4fe84b86ad4a40945329">GetLowestPing</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8324e15260b26b92abb204ed9f04ff57">SetOccasionalPing</a> (bool doPing)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#dacf2d7a0a3b4044e534a6c2e6cbc73e">GetRemoteStaticData</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5eac39c3ad8ffd3ed232e36ae27c882f">SetRemoteStaticData</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId, const char *data, const int length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d59d89dd83cba7de2d171b659b95a229">SendStaticData</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> target)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7d7601d2d7114c454829c655dc9e79c7">SetOfflinePingResponse</a> (const char *data, const unsigned int length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#588965b03942d2008a8ab40d9d06b992">GetInternalID</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#19f960c120278c7bfedd0df0742f02ef">GetExternalID</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> target) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a30685116ddc9a1d21eef81dd1a9822f">SetTimeoutTime</a> (RakNetTime timeMS, const <a class="el" href="structPlayerID.html">PlayerID</a> target)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#04cfe8d6a91f892b978af2ded06dd967">SetMTUSize</a> (int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8bb37bf48b402b4b9600f4af8613fd68">GetMTUSize</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6c72f0af658cebb78c7ed352a3f458f"></a><!-- doxytag: member="RakPeer::GetNumberOfAddresses" ref="c6c72f0af658cebb78c7ed352a3f458f" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c6c72f0af658cebb78c7ed352a3f458f">GetNumberOfAddresses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of IP addresses this system has internally. Get the actual addresses from <a class="el" href="classRakPeer.html#683896750aa0a4c9e4978c3090d54b10">GetLocalIP()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="683896750aa0a4c9e4978c3090d54b10"></a><!-- doxytag: member="RakPeer::GetLocalIP" ref="683896750aa0a4c9e4978c3090d54b10" args="(unsigned int index)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#683896750aa0a4c9e4978c3090d54b10">GetLocalIP</a> (unsigned int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an IP address at index 0 to GetNumberOfAddresses-1. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#49905f0c001ad4d88b802a15799d5f72">PlayerIDToDottedIP</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e360164606877bbd8df3b8c0e8b614ae">IPToPlayerID</a> (const char *host, unsigned short remotePort, <a class="el" href="structPlayerID.html">PlayerID</a> *playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#6073a5dffd55cbd7dbfc6e575c34ffc4">AllowConnectionResponseIPMigration</a> (bool allow)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5840d7c17689618bbb76e0a6fa0d1a33">AdvertiseSystem</a> (const char *host, unsigned short remotePort, const char *data, int dataLength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c1cb3f6aeaa842c721bbe4a3d74c3d5d">SetSplitMessageProgressInterval</a> (int interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#699049419ad22610064ef595cde4560e">SetUnreliableTimeout</a> (RakNetTime timeoutMS)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e20dde8c8397a680c70bdc9f6639ca58">SetCompileFrequencyTable</a> (bool doCompile)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8b3d828002aa9946b2556f657e33f0d8">GetOutgoingFrequencyTable</a> (unsigned int outputFrequencyTable[256])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9">GenerateCompressionLayer</a> (unsigned int inputFrequencyTable[256], bool inputLayer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c030c867c8e685d11d0789417fdf6aaa">DeleteCompressionLayer</a> (bool inputLayer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b8d51c7aa3bd6662b8ee3fbd618f4c11">GetCompressionRatio</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3469f4f4b4c38bf749cb394b466b823b">GetDecompressionRatio</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a8b050274c0eddf19dce37061a2d9d4e">AttachPlugin</a> (<a class="el" href="classPluginInterface.html">PluginInterface</a> *plugin)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b8ed7746af296fe30932645a1aef93f3">DetachPlugin</a> (<a class="el" href="classPluginInterface.html">PluginInterface</a> *messageHandler)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#9968ebdb31bcc7563b035a567046169b">PushBackPacket</a> (<a class="el" href="structPacket.html">Packet</a> *packet, bool pushAtHead)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a007c320065e2e390bdfe91a54bdfb3"></a><!-- doxytag: member="RakPeer::SetRouterInterface" ref="3a007c320065e2e390bdfe91a54bdfb3" args="(RouterInterface *routerInterface)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3a007c320065e2e390bdfe91a54bdfb3">SetRouterInterface</a> (<a class="el" href="classRouterInterface.html">RouterInterface</a> *routerInterface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
</p>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5c75a11b9732b1061155b730509cb6a"></a><!-- doxytag: member="RakPeer::RemoveRouterInterface" ref="c5c75a11b9732b1061155b730509cb6a" args="(RouterInterface *routerInterface)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c5c75a11b9732b1061155b730509cb6a">RemoveRouterInterface</a> (<a class="el" href="classRouterInterface.html">RouterInterface</a> *routerInterface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
</p>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#bedf3d97a62ee5011b4e1fe9ae6f25e0">ApplyNetworkSimulator</a> (double maxSendBPS, unsigned short minExtraPing, unsigned short extraPingVariance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#972f872d20bb187a0bbb92f29d4ae34f">IsNetworkSimulatorActive</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structRakNetStatisticsStruct.html">RakNetStatisticsStruct</a> *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2e8d282a4c8795bb3634f766d58ce5f7">GetStatistics</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7741ad8b901221dda91d7e0f5c7ea349"></a><!-- doxytag: member="RakPeer::GetRPCMap" ref="7741ad8b901221dda91d7e0f5c7ea349" args="(const PlayerID playerId)" -->
RPCMap *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRPCMap</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>offlinePingResponse_Mutex</b>, 
<b>NUMBER_OF_RAKPEER_MUTEXES</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42a315d4284ba99642ea08d3988e258d"></a><!-- doxytag: member="RakPeer::ReceiveIgnoreRPC" ref="42a315d4284ba99642ea08d3988e258d" args="(void)" -->
<a class="el" href="structPacket.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ReceiveIgnoreRPC</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec2cabaee6a720410e1a967845eefea1"></a><!-- doxytag: member="RakPeer::GetIndexFromPlayerID" ref="ec2cabaee6a720410e1a967845eefea1" args="(const PlayerID playerId, bool calledFromNetworkThread)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIndexFromPlayerID</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool calledFromNetworkThread)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cd0e12abffe735f28608eb88887e9c0"></a><!-- doxytag: member="RakPeer::SendConnectionRequest" ref="3cd0e12abffe735f28608eb88887e9c0" args="(const char *host, unsigned short remotePort, char *passwordData, int passwordDataLength)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>SendConnectionRequest</b> (const char *host, unsigned short remotePort, char *passwordData, int passwordDataLength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c9d7129b65ebc11d03bd3abb67390deb">GetRemoteSystemFromPlayerID</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerID, bool calledFromNetworkThread, bool onlyActive) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="edcd9b44bfbbbded37c044f50ae453ff"></a><!-- doxytag: member="RakPeer::ParseConnectionRequestPacket" ref="edcd9b44bfbbbded37c044f50ae453ff" args="(RakPeer::RemoteSystemStruct *remoteSystem, PlayerID playerId, const char *data, int byteSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#edcd9b44bfbbbded37c044f50ae453ff">ParseConnectionRequestPacket</a> (RakPeer::RemoteSystemStruct *remoteSystem, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, const char *data, int byteSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse out a connection request packet. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6abbfdfa442c73572f034475a170c5b8"></a><!-- doxytag: member="RakPeer::OnConnectionRequest" ref="6abbfdfa442c73572f034475a170c5b8" args="(RakPeer::RemoteSystemStruct *remoteSystem, unsigned char *AESKey, bool setAESKey)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#6abbfdfa442c73572f034475a170c5b8">OnConnectionRequest</a> (RakPeer::RemoteSystemStruct *remoteSystem, unsigned char *AESKey, bool setAESKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When we get a connection request from an ip / port, accept it unless full. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca3686767968fc9bc8a8e70556212b3a"></a><!-- doxytag: member="RakPeer::NotifyAndFlagForDisconnect" ref="ca3686767968fc9bc8a8e70556212b3a" args="(const PlayerID playerId, bool performImmediate, unsigned char orderingChannel)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ca3686767968fc9bc8a8e70556212b3a">NotifyAndFlagForDisconnect</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool performImmediate, unsigned char orderingChannel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a reliable disconnect packet to this player and disconnect them when it is delivered. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01b7ddd20ebdcc83fe272da5670e1394"></a><!-- doxytag: member="RakPeer::GetNumberOfRemoteInitiatedConnections" ref="01b7ddd20ebdcc83fe272da5670e1394" args="(void) const " -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#01b7ddd20ebdcc83fe272da5670e1394">GetNumberOfRemoteInitiatedConnections</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many remote systems initiated a connection to us. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#0440d46828eb4fd7927c077b7191925f">AssignPlayerIDToRemoteSystemList</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId, RemoteSystemStruct::ConnectMode connectionMode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a free remote system from the list and assign our playerID to it. Should only be called from the update thread - not the user thread.  <a href="#0440d46828eb4fd7927c077b7191925f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbb151509a8e497216cea50c76644a14"></a><!-- doxytag: member="RakPeer::ShiftIncomingTimestamp" ref="cbb151509a8e497216cea50c76644a14" args="(unsigned char *data, PlayerID playerId) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#cbb151509a8e497216cea50c76644a14">ShiftIncomingTimestamp</a> (unsigned char *data, <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An incoming packet has a timestamp, so adjust it to be relative to this system. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a01e3c12853acb4765a49ef00d832543"></a><!-- doxytag: member="RakPeer::GetBestClockDifferential" ref="a01e3c12853acb4765a49ef00d832543" args="(const PlayerID playerId) const " -->
RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a01e3c12853acb4765a49ef00d832543">GetBestClockDifferential</a> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the most probably accurate clock differential for a certain player. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#1192b8d0540c866a231d6f636d144c16">HandleRPCPacket</a> (const char *data, int length, <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2a08d04192621dae2fdeeb1668daadc6">HandleRPCReplyPacket</a> (const char *data, int length, <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67f1361e511f17e2f58bd53eebcb8099"></a><!-- doxytag: member="RakPeer::GenerateSYNCookieRandomNumber" ref="67f1361e511f17e2f58bd53eebcb8099" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GenerateSYNCookieRandomNumber</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d36b13e7c33b4c7c386f724f75fa879"></a><!-- doxytag: member="RakPeer::SecuredConnectionResponse" ref="3d36b13e7c33b4c7c386f724f75fa879" args="(const PlayerID playerId)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SecuredConnectionResponse</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a50b98fa478c759d7ad6179a9e653a62"></a><!-- doxytag: member="RakPeer::SecuredConnectionConfirmation" ref="a50b98fa478c759d7ad6179a9e653a62" args="(RakPeer::RemoteSystemStruct *remoteSystem, char *data)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SecuredConnectionConfirmation</b> (RakPeer::RemoteSystemStruct *remoteSystem, char *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="62e4ae9a0f20ea038090996062dca805"></a><!-- doxytag: member="RakPeer::RunUpdateCycle" ref="62e4ae9a0f20ea038090996062dca805" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>RunUpdateCycle</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25b2da73418842f2a655199cb434a859"></a><!-- doxytag: member="RakPeer::AllowIncomingConnections" ref="25b2da73418842f2a655199cb434a859" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>AllowIncomingConnections</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eba64a12dedd03cb0f46941f9b2354dd"></a><!-- doxytag: member="RakPeer::SendStaticDataInternal" ref="eba64a12dedd03cb0f46941f9b2354dd" args="(const PlayerID target, bool performImmediate)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SendStaticDataInternal</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> target, bool performImmediate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1599d8ba83cc6d36b0c5239053741246"></a><!-- doxytag: member="RakPeer::PingInternal" ref="1599d8ba83cc6d36b0c5239053741246" args="(const PlayerID target, bool performImmediate)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PingInternal</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> target, bool performImmediate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498d502054d5d7bb0011c05eb4000e90"></a><!-- doxytag: member="RakPeer::ValidSendTarget" ref="498d502054d5d7bb0011c05eb4000e90" args="(PlayerID playerId, bool broadcast)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValidSendTarget</b> (<a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e106ba2b1330fe08e95ac4a839c44d6e"></a><!-- doxytag: member="RakPeer::CloseConnectionInternal" ref="e106ba2b1330fe08e95ac4a839c44d6e" args="(const PlayerID target, bool sendDisconnectionNotification, bool performImmediate, unsigned char orderingChannel)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CloseConnectionInternal</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> target, bool sendDisconnectionNotification, bool performImmediate, unsigned char orderingChannel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc78127241850524122651c4ec18bded"></a><!-- doxytag: member="RakPeer::SendBuffered" ref="bc78127241850524122651c4ec18bded" args="(const char *data, int numberOfBitsToSend, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, RemoteSystemStruct::ConnectMode connectionMode)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SendBuffered</b> (const char *data, int numberOfBitsToSend, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast, RemoteSystemStruct::ConnectMode connectionMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="438e70b42a11afd73a5636fa8b5e8a12"></a><!-- doxytag: member="RakPeer::SendImmediate" ref="438e70b42a11afd73a5636fa8b5e8a12" args="(char *data, int numberOfBitsToSend, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool useCallerDataAllocation, RakNetTimeNS currentTime)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>SendImmediate</b> (char *data, int numberOfBitsToSend, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast, bool useCallerDataAllocation, RakNetTimeNS currentTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed8c82143ba074c034ebf6f7ada9e06f"></a><!-- doxytag: member="RakPeer::ClearBufferedCommands" ref="ed8c82143ba074c034ebf6f7ada9e06f" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearBufferedCommands</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3a210565120570bcdab5332ab16e336"></a><!-- doxytag: member="RakPeer::ClearRequestedConnectionList" ref="e3a210565120570bcdab5332ab16e336" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearRequestedConnectionList</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="08b637a0edc34987df21f14b6c98caa0"></a><!-- doxytag: member="RakPeer::AddPacketToProducer" ref="08b637a0edc34987df21f14b6c98caa0" args="(Packet *p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddPacketToProducer</b> (<a class="el" href="structPacket.html">Packet</a> *p)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7cfe43a66680f16050b43df0118a0f00"></a><!-- doxytag: member="RakPeer::endThreads" ref="7cfe43a66680f16050b43df0118a0f00" args="" -->
volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7cfe43a66680f16050b43df0118a0f00">endThreads</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this to true to terminate the Peer thread execution. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55544eb11720fe938193c6b79bc65d18"></a><!-- doxytag: member="RakPeer::isMainLoopThreadActive" ref="55544eb11720fe938193c6b79bc65d18" args="" -->
volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#55544eb11720fe938193c6b79bc65d18">isMainLoopThreadActive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if the peer thread is active. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab1dc5565fbf4b64c475ceb35780e6a9"></a><!-- doxytag: member="RakPeer::occasionalPing" ref="ab1dc5565fbf4b64c475ceb35780e6a9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>occasionalPing</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">*unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#af0f4145d68e3aab994aa58dabd8047e">maximumNumberOfPeers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the maximum number of peers allowed to connect.  <a href="#af0f4145d68e3aab994aa58dabd8047e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ac75ac0847890a84a490143e7499dd8"></a><!-- doxytag: member="RakPeer::maximumIncomingConnections" ref="8ac75ac0847890a84a490143e7499dd8" args="" -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8ac75ac0847890a84a490143e7499dd8">maximumIncomingConnections</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the maximum incoming connection allowed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2373f1182855dd82ff40f4599c838a84"></a><!-- doxytag: member="RakPeer::localStaticData" ref="2373f1182855dd82ff40f4599c838a84" args="" -->
<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2373f1182855dd82ff40f4599c838a84">localStaticData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">localStaticData necessary because we may not have a RemoteSystemStruct representing ourselves in the list <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b57e61df63648c3ef23b08235c8f977"></a><!-- doxytag: member="RakPeer::offlinePingResponse" ref="3b57e61df63648c3ef23b08235c8f977" args="" -->
<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>offlinePingResponse</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27ebba234ec7f3e0e083124ed2fefb81"></a><!-- doxytag: member="RakPeer::myPlayerId" ref="27ebba234ec7f3e0e083124ed2fefb81" args="" -->
<a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#27ebba234ec7f3e0e083124ed2fefb81">myPlayerId</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local Player ID. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f8adcae3bdebf68d7f93706c3c3fd83"></a><!-- doxytag: member="RakPeer::incomingPassword" ref="7f8adcae3bdebf68d7f93706c3c3fd83" args="[256]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><b>incomingPassword</b> [256]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ba008037e8c344907cc9e20dd98d51c"></a><!-- doxytag: member="RakPeer::incomingPasswordLength" ref="1ba008037e8c344907cc9e20dd98d51c" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>incomingPasswordLength</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#fac48c9f0bb054679a435ea8eb309181">remoteSystemList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75fb64397d362791b3f77813b734d3e7"></a><!-- doxytag: member="RakPeer::remoteSystemLookup" ref="75fb64397d362791b3f77813b734d3e7" args="" -->
<a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<br>
 <a class="el" href="structPlayerID.html">PlayerID</a>, PlayerIDAndIndex,<br>
 PlayerIDAndIndexComp &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>remoteSystemLookup</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95e720912790ac7e72c26d3ecca12bbd"></a><!-- doxytag: member="RakPeer::rakPeerMutexes" ref="95e720912790ac7e72c26d3ecca12bbd" args="[NUMBER_OF_RAKPEER_MUTEXES]" -->
<a class="el" href="classSimpleMutex.html">SimpleMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>rakPeerMutexes</b> [NUMBER_OF_RAKPEER_MUTEXES]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="886adb8f6d621863a031f7eee9ce3041"></a><!-- doxytag: member="RakPeer::updateCycleIsRunning" ref="886adb8f6d621863a031f7eee9ce3041" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#886adb8f6d621863a031f7eee9ce3041">updateCycleIsRunning</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RunUpdateCycle is not thread safe but we don't need to mutex calls. Just skip calls if it is running already. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba1ca9377af6817e35620c47bc89887f"></a><!-- doxytag: member="RakPeer::bytesSentPerSecond" ref="ba1ca9377af6817e35620c47bc89887f" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ba1ca9377af6817e35620c47bc89887f">bytesSentPerSecond</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data that both the client and the server needs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c523052d76419fbfcc5f64954b4550c"></a><!-- doxytag: member="RakPeer::bytesReceivedPerSecond" ref="9c523052d76419fbfcc5f64954b4550c" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bytesReceivedPerSecond</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ec38c4d8bea81efc596b896c4dae262"></a><!-- doxytag: member="RakPeer::validationInteger" ref="7ec38c4d8bea81efc596b896c4dae262" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>validationInteger</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33dcbab982dc5b88ec64f68d36749619"></a><!-- doxytag: member="RakPeer::processPacketsThreadHandle" ref="33dcbab982dc5b88ec64f68d36749619" args="" -->
pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>processPacketsThreadHandle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="859602fa3b0ed5dee004a1354c9bc3e4"></a><!-- doxytag: member="RakPeer::recvfromThreadHandle" ref="859602fa3b0ed5dee004a1354c9bc3e4" args="" -->
pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>recvfromThreadHandle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f39e4a13b6c7a6ceba1b0e9d11a3881"></a><!-- doxytag: member="RakPeer::incomingQueueMutex" ref="5f39e4a13b6c7a6ceba1b0e9d11a3881" args="" -->
<a class="el" href="classSimpleMutex.html">SimpleMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>incomingQueueMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36dc1f6eab22b68e53952868b86de464"></a><!-- doxytag: member="RakPeer::banListMutex" ref="36dc1f6eab22b68e53952868b86de464" args="" -->
<a class="el" href="classSimpleMutex.html">SimpleMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>banListMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ded478111c3a0db29e309244b4897e87"></a><!-- doxytag: member="RakPeer::banList" ref="ded478111c3a0db29e309244b4897e87" args="" -->
<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; BanStruct * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>banList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2646f125d30d567664c4cd7cad71d8bb"></a><!-- doxytag: member="RakPeer::messageHandlerList" ref="2646f125d30d567664c4cd7cad71d8bb" args="" -->
<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="classPluginInterface.html">PluginInterface</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>messageHandlerList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4cd4f1fab0223d4500a9eb82110cf3ef"></a><!-- doxytag: member="RakPeer::requestedConnectionList" ref="4cd4f1fab0223d4500a9eb82110cf3ef" args="" -->
<a class="el" href="classDataStructures_1_1SingleProducerConsumer.html">DataStructures::SingleProducerConsumer</a>&lt;<br>
 RequestedConnectionStruct &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>requestedConnectionList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="addf5f5e8397c893518952c2421b1709"></a><!-- doxytag: member="RakPeer::frequencyTable" ref="addf5f5e8397c893518952c2421b1709" args="[256]" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#addf5f5e8397c893518952c2421b1709">frequencyTable</a> [256]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compression stuff. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4fbb58309688020f175358c61b96263"></a><!-- doxytag: member="RakPeer::inputTree" ref="a4fbb58309688020f175358c61b96263" args="" -->
<a class="el" href="classHuffmanEncodingTree.html">HuffmanEncodingTree</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>inputTree</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94aae16f800fb5aceb28feae936103ed"></a><!-- doxytag: member="RakPeer::outputTree" ref="94aae16f800fb5aceb28feae936103ed" args="" -->
<a class="el" href="classHuffmanEncodingTree.html">HuffmanEncodingTree</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>outputTree</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47b8d7125f9036056f63f7219924f115"></a><!-- doxytag: member="RakPeer::rawBytesSent" ref="47b8d7125f9036056f63f7219924f115" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>rawBytesSent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee45ed4afb222f85d527505d9f7c4e45"></a><!-- doxytag: member="RakPeer::rawBytesReceived" ref="ee45ed4afb222f85d527505d9f7c4e45" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>rawBytesReceived</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c02d1730f41803de356c9863dacdebba"></a><!-- doxytag: member="RakPeer::compressedBytesSent" ref="c02d1730f41803de356c9863dacdebba" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compressedBytesSent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c9eff58c97470caafa8b9a507520d591"></a><!-- doxytag: member="RakPeer::compressedBytesReceived" ref="c9eff58c97470caafa8b9a507520d591" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compressedBytesReceived</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9a737baae4e1076522d1e15ec77fabc"></a><!-- doxytag: member="RakPeer::bufferedCommands" ref="b9a737baae4e1076522d1e15ec77fabc" args="" -->
<a class="el" href="classDataStructures_1_1SingleProducerConsumer.html">DataStructures::SingleProducerConsumer</a>&lt;<br>
 BufferedCommandStruct &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferedCommands</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef80d6ed729f754aaaf37dace7e479c9"></a><!-- doxytag: member="RakPeer::rpcMap" ref="ef80d6ed729f754aaaf37dace7e479c9" args="" -->
RPCMap&nbsp;</td><td class="memItemRight" valign="bottom"><b>rpcMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b4c0fad4cc3fd8d9f022529a48686330"></a><!-- doxytag: member="RakPeer::MTUSize" ref="b4c0fad4cc3fd8d9f022529a48686330" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>MTUSize</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbdc59c7d6a3eaf8acc8b1f0933c8da5"></a><!-- doxytag: member="RakPeer::trackFrequencyTable" ref="bbdc59c7d6a3eaf8acc8b1f0933c8da5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>trackFrequencyTable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e061927926751d8a957c747afeafc36"></a><!-- doxytag: member="RakPeer::threadSleepTimer" ref="7e061927926751d8a957c747afeafc36" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>threadSleepTimer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="49509b094e46abfbf44aaf41c626964b"></a><!-- doxytag: member="RakPeer::connectionSocket" ref="49509b094e46abfbf44aaf41c626964b" args="" -->
<a class="el" href="TCPInterface_8h.html#8dc8083897335125630f1af5dafd5831">SOCKET</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>connectionSocket</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54854681c4c3488d859eb96c65482f27"></a><!-- doxytag: member="RakPeer::replyFromTargetBS" ref="54854681c4c3488d859eb96c65482f27" args="" -->
<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>replyFromTargetBS</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d84690f703c5a4ccdbc3e49bafdadc0"></a><!-- doxytag: member="RakPeer::replyFromTargetPlayer" ref="6d84690f703c5a4ccdbc3e49bafdadc0" args="" -->
<a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>replyFromTargetPlayer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4332049ae15c60b2458daacb72e377e"></a><!-- doxytag: member="RakPeer::replyFromTargetBroadcast" ref="c4332049ae15c60b2458daacb72e377e" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>replyFromTargetBroadcast</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5776c99ef47d0d852e97dac47c20e81a"></a><!-- doxytag: member="RakPeer::blockOnRPCReply" ref="5776c99ef47d0d852e97dac47c20e81a" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>blockOnRPCReply</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0148eba56894e5a1dcc02f17eedd842b"></a><!-- doxytag: member="RakPeer::router" ref="0148eba56894e5a1dcc02f17eedd842b" args="" -->
<a class="el" href="classRouterInterface.html">RouterInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>router</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="446615e19bd6f74b681ededfa0b93281"></a><!-- doxytag: member="RakPeer::_maxSendBPS" ref="446615e19bd6f74b681ededfa0b93281" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>_maxSendBPS</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ccf7a902e41b8ed51da1876b8cfa1063"></a><!-- doxytag: member="RakPeer::_minExtraPing" ref="ccf7a902e41b8ed51da1876b8cfa1063" args="" -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><b>_minExtraPing</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25bd8e09e6eaa2c588e53dfd1a1e6f8a"></a><!-- doxytag: member="RakPeer::_extraPingVariance" ref="25bd8e09e6eaa2c588e53dfd1a1e6f8a" args="" -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><b>_extraPingVariance</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df9942d8dcb41623db9fc6ff7473fce5"></a><!-- doxytag: member="RakPeer::rsacrypt" ref="df9942d8dcb41623db9fc6ff7473fce5" args="" -->
big::RSACrypt&lt; RSA_BIT_SIZE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#df9942d8dcb41623db9fc6ff7473fce5">rsacrypt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encryption and security. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c277eb86425517a018b034d2f634f8b9"></a><!-- doxytag: member="RakPeer::publicKeyE" ref="c277eb86425517a018b034d2f634f8b9" args="" -->
<a class="el" href="namespacecat.html#a64ecaf17bf2ebb25abd717ee7438161">big::u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>publicKeyE</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c721679cb0af767662a4bb87673016f"></a><!-- doxytag: member="RakPeer::publicKeyN" ref="4c721679cb0af767662a4bb87673016f" args="" -->
RSA_BIT_SIZE&nbsp;</td><td class="memItemRight" valign="bottom"><b>publicKeyN</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30421f901418369a034cc6a944a9b8e3"></a><!-- doxytag: member="RakPeer::keysLocallyGenerated" ref="30421f901418369a034cc6a944a9b8e3" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>keysLocallyGenerated</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c0c8ca8da09005adeff319da9b92b9e"></a><!-- doxytag: member="RakPeer::usingSecurity" ref="1c0c8ca8da09005adeff319da9b92b9e" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>usingSecurity</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d103c7f10a629cf9663a309ea2341562"></a><!-- doxytag: member="RakPeer::randomNumberExpirationTime" ref="d103c7f10a629cf9663a309ea2341562" args="" -->
RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><b>randomNumberExpirationTime</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f3af3ed7d067e695e7f56630639653d"></a><!-- doxytag: member="RakPeer::newRandomNumber" ref="0f3af3ed7d067e695e7f56630639653d" args="[20]" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>newRandomNumber</b> [20]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="88d371eb4ff6bf1e1038268a204047fd"></a><!-- doxytag: member="RakPeer::oldRandomNumber" ref="88d371eb4ff6bf1e1038268a204047fd" args="[20]" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>oldRandomNumber</b> [20]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8dc645e7f22a90abe45dfc3fdc74044f"></a><!-- doxytag: member="RakPeer::allowConnectionResponseIPMigration" ref="8dc645e7f22a90abe45dfc3fdc74044f" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8dc645e7f22a90abe45dfc3fdc74044f">allowConnectionResponseIPMigration</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True to allow connection accepted packets from anyone. False to only allow these packets from servers we requested a connection to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bded6e698cac288c280bbf62c7e1f515"></a><!-- doxytag: member="RakPeer::splitMessageProgressInterval" ref="bded6e698cac288c280bbf62c7e1f515" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>splitMessageProgressInterval</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6fdcbcb323223715dc70fd0522f19a0"></a><!-- doxytag: member="RakPeer::unreliableTimeout" ref="f6fdcbcb323223715dc70fd0522f19a0" args="" -->
RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><b>unreliableTimeout</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8eb3082931780a6e175c1ae93ce30362"></a><!-- doxytag: member="RakPeer::packetSingleProducerConsumer" ref="8eb3082931780a6e175c1ae93ce30362" args="" -->
<a class="el" href="classDataStructures_1_1SingleProducerConsumer.html">DataStructures::SingleProducerConsumer</a>&lt;<br>
 <a class="el" href="structPacket.html">Packet</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>packetSingleProducerConsumer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4728b7e7bfc771b8f7852bea65880baf"></a><!-- doxytag: member="RakPeer::packetPool" ref="4728b7e7bfc771b8f7852bea65880baf" args="" -->
<a class="el" href="classDataStructures_1_1Queue.html">DataStructures::Queue</a>&lt; <a class="el" href="structPacket.html">Packet</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>packetPool</b></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b29fa21dad9c9b824699966cca5ded99"></a><!-- doxytag: member="RakPeer::ProcessPortUnreachable" ref="b29fa21dad9c9b824699966cca5ded99" args="(const unsigned int binaryAddress, const unsigned short port, RakPeer *rakPeer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ProcessPortUnreachable</b> (const unsigned int binaryAddress, const unsigned short port, <a class="el" href="classRakPeer.html">RakPeer</a> *rakPeer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8f1d0adb2973fee11ae9950fd3504df"></a><!-- doxytag: member="RakPeer::ProcessNetworkPacket" ref="b8f1d0adb2973fee11ae9950fd3504df" args="(const unsigned int binaryAddress, const unsigned short port, const char *data, const int length, RakPeer *rakPeer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ProcessNetworkPacket</b> (const unsigned int binaryAddress, const unsigned short port, const char *data, const int length, <a class="el" href="classRakPeer.html">RakPeer</a> *rakPeer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ef1cb6e14b5f8319e1d3ef2632806ac"></a><!-- doxytag: member="RakPeer::UpdateNetworkLoop" ref="9ef1cb6e14b5f8319e1d3ef2632806ac" args="(void *arguments)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>UpdateNetworkLoop</b> (void *arguments)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>BanStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>BufferedCommandStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRakPeer_1_1MemoryBlock.html">MemoryBlock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatic Variable Synchronization Mechanism automatic variable synchronization takes a primary and secondary identifier The unique primary identifier is the index into the automaticVariableSynchronizationList The unique secondary identifier (UNASSIGNED_NETWORK_ID for none) is in an unsorted list of memory blocks.  <a href="structRakPeer_1_1MemoryBlock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>PingAndClockDifferential</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoteSystemStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RequestedConnectionStruct</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The main interface for network communications. 
<p>
The primary interface for <a class="el" href="namespaceRakNet.html">RakNet</a>, <a class="el" href="classRakPeer.html">RakPeer</a> contains all major functions for the library. See the individual functions for what the class can do. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8f641435cc9a86c48ad5f105ed4e74ed"></a><!-- doxytag: member="RakPeer::AddToBanList" ref="8f641435cc9a86c48ad5f105ed4e74ed" args="(const char *IP, RakNetTime milliseconds=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::AddToBanList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>IP</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RakNetTime&nbsp;</td>
          <td class="mdname" nowrap> <em>milliseconds</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bans an IP from connecting. Banned IPs persist between connections but are not saved on shutdown nor loaded on startup. param[in] IP Dotted IP address. Can use * as a wildcard, such as 128.0.0.* will ban all IP addresses starting with 128.0.0 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>milliseconds</em>&nbsp;</td><td>how many ms for a temporary ban. Use 0 for a permanent ban </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#2bd5066568cb0ceffd622bc83a674d9c">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="5840d7c17689618bbb76e0a6fa0d1a33"></a><!-- doxytag: member="RakPeer::AdvertiseSystem" ref="5840d7c17689618bbb76e0a6fa0d1a33" args="(const char *host, unsigned short remotePort, const char *data, int dataLength)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::AdvertiseSystem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dataLength</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will tell the remote system our external IP outside the LAN along with some user data. <dl compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Optional data to append to the packet. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataLength</em>&nbsp;</td><td>length of data in bytes. Use 0 if no data. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#37aae9f4aebc6cff39cc7840e0de92a4">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#eea62bc7ea8134366a0226810c303289">RakClient</a>, and <a class="el" href="classRakServer.html#788a15d6d34aba71e04b4038b3165993">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="6073a5dffd55cbd7dbfc6e575c34ffc4"></a><!-- doxytag: member="RakPeer::AllowConnectionResponseIPMigration" ref="6073a5dffd55cbd7dbfc6e575c34ffc4" args="(bool allow)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::AllowConnectionResponseIPMigration           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>allow</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allow or disallow connection responses from any IP. Normally this should be false, but may be necessary when connecting to servers with multiple IP addresses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow</em>&nbsp;</td><td>- True to allow this behavior, false to not allow. Defaults to false. Value persists between connections </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#6d6f317bc7bc9ff3dfc3b3044df7242f">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#5d52403992c011a5658de5b58cc18789">RakClient</a>.    </td>
  </tr>
</table>
<a class="anchor" name="bedf3d97a62ee5011b4e1fe9ae6f25e0"></a><!-- doxytag: member="RakPeer::ApplyNetworkSimulator" ref="bedf3d97a62ee5011b4e1fe9ae6f25e0" args="(double maxSendBPS, unsigned short minExtraPing, unsigned short extraPingVariance)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::ApplyNetworkSimulator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>maxSendBPS</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>minExtraPing</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>extraPingVariance</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds simulated ping and packet loss to the outgoing data flow. To simulate bi-directional ping and packet loss, you should call this on both the sender and the recipient, with half the total ping and maxSendBPS value on each. You can exclude network simulator code with the _RELEASE define to decrease code size <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxSendBPS</em>&nbsp;</td><td>Maximum bits per second to send. Packetloss grows linearly. 0 to disable. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minExtraPing</em>&nbsp;</td><td>The minimum time to delay sends. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>extraPingVariance</em>&nbsp;</td><td>The additional random time to delay sends. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#82b7921af27e0424b98e799d8ad09dce">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#b5643cbbe37faf778ad87c7dd6694d0b">RakClient</a>, and <a class="el" href="classRakServer.html#b9bdafb45122f8401477c00e515996df">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="0440d46828eb4fd7927c077b7191925f"></a><!-- doxytag: member="RakPeer::AssignPlayerIDToRemoteSystemList" ref="0440d46828eb4fd7927c077b7191925f" args="(const PlayerID playerId, RemoteSystemStruct::ConnectMode connectionMode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RakPeer::RemoteSystemStruct * RakPeer::AssignPlayerIDToRemoteSystemList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RemoteSystemStruct::ConnectMode&nbsp;</td>
          <td class="mdname" nowrap> <em>connectionMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a free remote system from the list and assign our playerID to it. Should only be called from the update thread - not the user thread. 
<p>
Add this player to the lookup tree     </td>
  </tr>
</table>
<a class="anchor" name="a8b050274c0eddf19dce37061a2d9d4e"></a><!-- doxytag: member="RakPeer::AttachPlugin" ref="a8b050274c0eddf19dce37061a2d9d4e" args="(PluginInterface *plugin)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::AttachPlugin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPluginInterface.html">PluginInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>plugin</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attatches a Plugin interface to run code automatically on message receipt in the Receive call <dl compact><dt><b>Note:</b></dt><dd>If plugins have dependencies on each other then the order does matter - for example the router plugin should go first because it might route messages for other plugins </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to a plugin to attach </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#2c678b6387b838e1dbb45fb5cf530c16">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#6ab185fe6ccf5b6f3f4151f0ee384b8f">RakClient</a>, and <a class="el" href="classRakServer.html#f16522519b7c94dab6b96950b4afc3b3">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="cc60e0732bd685a2f0216831e4cb43f3"></a><!-- doxytag: member="RakPeer::CloseConnection" ref="cc60e0732bd685a2f0216831e4cb43f3" args="(const PlayerID target, bool sendDisconnectionNotification, unsigned char orderingChannel=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::CloseConnection           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>sendDisconnectionNotification</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>orderingChannel</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to close the connection to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendDisconnectionNotification</em>&nbsp;</td><td>True to send ID_DISCONNECTION_NOTIFICATION to the recipient. False to close it silently. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Which ordering channel to send the disconnection notification on, if any </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#760e38d79b30e2ced458709e2d25c026">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="80e98d77e4140079634ebb284c4168f8"></a><!-- doxytag: member="RakPeer::Connect" ref="80e98d77e4140079634ebb284c4168f8" args="(const char *host, unsigned short remotePort, char *passwordData, int passwordDataLength)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::Connect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordDataLength</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect to the specified host (ip or domain name) and server port. Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer. This is a non-blocking connection. You know the connection is successful when IsConnected() returns true or <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">Receive()</a> gets a message with the type identifier ID_CONNECTION_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Requires that you first call Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to SetIncomingPassword. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True on successful initiation. False on incorrect parameters, internal error, or too many existing peers. Returning true does not mean you connected! </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#2a3116e207dd9ac71cef67d84ef30a82">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f68f8d2766b45b6d951dfd62cf349a71"></a><!-- doxytag: member="RakPeer::DeallocatePacket" ref="f68f8d2766b45b6d951dfd62cf349a71" args="(Packet *packet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::DeallocatePacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>packet</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this to deallocate a message returned by <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">Receive()</a> when you are done handling it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>The message to deallocate. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#8e792f3d13652387fcf12542bc1cd2be">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#8c94036bdaf7ac0b803c4ae2ffc3141a">RakClient</a>, and <a class="el" href="classRakServer.html#7bc138b1da62684ef76af79171885634">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="c030c867c8e685d11d0789417fdf6aaa"></a><!-- doxytag: member="RakPeer::DeleteCompressionLayer" ref="c030c867c8e685d11d0789417fdf6aaa" args="(bool inputLayer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::DeleteCompressionLayer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>inputLayer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete the output or input layer as specified. This is not necessary to call and is only valuable for freeing memory. <dl compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputLayer</em>&nbsp;</td><td>True to mean the inputLayer, false to mean the output layer </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>false (failure) if connected. Otherwise true (success) </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#5ae0c3a39a6d29458d12094988a67f40">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#8ab2947c751a8e6ccf0dc4d78ca8e4c7">RakClient</a>, and <a class="el" href="classRakServer.html#e9a7e27ed35bd624ca730058239de2c5">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b8ed7746af296fe30932645a1aef93f3"></a><!-- doxytag: member="RakPeer::DetachPlugin" ref="b8ed7746af296fe30932645a1aef93f3" args="(PluginInterface *messageHandler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::DetachPlugin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPluginInterface.html">PluginInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>messageHandler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Detaches a Plugin interface to run code automatically on message receipt <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to a plugin to detach </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#750f110b0539b48550a2bdb44f86de7b">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#b2043956bf3e931738bc36cfa7332153">RakClient</a>, and <a class="el" href="classRakServer.html#af9bceff5032759fa6eaa4b192e0e054">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="bc9e3cd4ac407f23ce1ee99c94cabd88"></a><!-- doxytag: member="RakPeer::DisableSecurity" ref="bc9e3cd4ac407f23ce1ee99c94cabd88" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::DisableSecurity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disables all security. <dl compact><dt><b>Note:</b></dt><dd>Must be called while offline </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#06966ce41b033b7c8a7e460333968c3b">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#455e4c5676ff681f8dcef342c2fdf43d">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="44dd4adfb061e1335cef84300f758b6a"></a><!-- doxytag: member="RakPeer::Disconnect" ref="44dd4adfb061e1335cef84300f758b6a" args="(unsigned int blockDuration, unsigned char orderingChannel=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::Disconnect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>blockDuration</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>orderingChannel</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stops the network threads and closes all connections. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blockDuration</em>&nbsp;</td><td>How long you should wait for all remaining messages to go out, including ID_DISCONNECTION_NOTIFICATION. If 0, it doesn't wait at all. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>If blockDuration &gt; 0, ID_DISCONNECTION_NOTIFICATION will be sent on this channel If you set it to 0 then the disconnection notification won't be sent </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#264c89b0bcc3c5c4bba195edac174f63">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#000b72d946b2ced753c4938dc2db3c1a">RakClient</a>, and <a class="el" href="classRakServer.html#03419a530d9e0341f4be275e3bc059dd">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f3b47a3087903697acac977e3525b8d9"></a><!-- doxytag: member="RakPeer::GenerateCompressionLayer" ref="f3b47a3087903697acac977e3525b8d9" args="(unsigned int inputFrequencyTable[256], bool inputLayer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::GenerateCompressionLayer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>inputFrequencyTable</em>[256], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>inputLayer</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is an optional function to generate the compression layer based on the input frequency table. If you want to use it you should call this twice - once with inputLayer as true and once as false. The frequency table passed here with inputLayer=true should match the frequency table on the recipient with inputLayer=false. Likewise, the frequency table passed here with inputLayer=false should match the frequency table on the recipient with inputLayer=true. Calling this function when there is an existing layer will overwrite the old layer. <dl compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputFrequencyTable</em>&nbsp;</td><td>A frequency table for your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputLayer</em>&nbsp;</td><td>Is this the input layer? </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>false (failure) if connected. Otherwise true (success) </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>Compression.cpp </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#db8ccf96299cc5cb92728b2cc98f9cb6">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#be86e3682fee89383374422de2a8d72e">RakClient</a>, and <a class="el" href="classRakServer.html#2db2f121f08edbbad8784f96dcc86891">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a857af87b64b9fe925b6664b010bf298"></a><!-- doxytag: member="RakPeer::GetAveragePing" ref="a857af87b64b9fe925b6664b010bf298" args="(const PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int RakPeer::GetAveragePing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the average of all ping times read for the specific system or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The ping time for this system, or -1 </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#0e3afee94f44770c266a05afe780f7cf">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#b68855e9de80cd0f0dc58f3c5270abb3">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b8d51c7aa3bd6662b8ee3fbd618f4c11"></a><!-- doxytag: member="RakPeer::GetCompressionRatio" ref="b8d51c7aa3bd6662b8ee3fbd618f4c11" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">float RakPeer::GetCompressionRatio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the compression ratio. A low compression ratio is good. Compression is for outgoing data <dl compact><dt><b>Returns:</b></dt><dd>The compression ratio </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#12249f11335df1ae09e2b560e9b5d0f2">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#eb0d5e4833a80b1424f55a4f4980385b">RakClient</a>, and <a class="el" href="classRakServer.html#2d028a1e5d6cb21b0be294a4688a57ed">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="0258deb9b3cdbc9c9c0eb39d61207798"></a><!-- doxytag: member="RakPeer::GetConnectionList" ref="0258deb9b3cdbc9c9c0eb39d61207798" args="(PlayerID *remoteSystems, unsigned short *numberOfSystems) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::GetConnectionList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>remoteSystems</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short *&nbsp;</td>
          <td class="mdname" nowrap> <em>numberOfSystems</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fills the array remoteSystems with the SystemID of all the systems we are connected to <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>remoteSystems</em>&nbsp;</td><td>An array of <a class="el" href="structPlayerID.html">PlayerID</a> structures to be filled with the PlayerIDs of the systems we are connected to. Pass 0 to remoteSystems to only get the number of systems we are connected to </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numberOfSystems</em>&nbsp;</td><td>As input, the size of remoteSystems array. As output, the number of elements put into the array </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#84cc93a30a35e06ad48877a2f85ac35c">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="3469f4f4b4c38bf749cb394b466b823b"></a><!-- doxytag: member="RakPeer::GetDecompressionRatio" ref="3469f4f4b4c38bf749cb394b466b823b" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">float RakPeer::GetDecompressionRatio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the decompression ratio. A high decompression ratio is good. Decompression is for incoming data <dl compact><dt><b>Returns:</b></dt><dd>The decompression ratio </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#89e447614d28c58e0bf3cbed5f36b734">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#1acb3310c0a013390d72e90e81d128b6">RakClient</a>, and <a class="el" href="classRakServer.html#104e82dc9cc5264845d8649a73e76552">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="19f960c120278c7bfedd0df0742f02ef"></a><!-- doxytag: member="RakPeer::GetExternalID" ref="19f960c120278c7bfedd0df0742f02ef" args="(const PlayerID target) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a> RakPeer::GetExternalID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>target</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the unique address identifier that represents you on the the network and is based on your externalIP / port (the IP / port the specified player uses to communicate with you) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which remote system you are referring to for your external ID. Usually the same for all systems, unless you have two or more network cards. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#bcc042b6d2770d132b9397bc8bacfa3c">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="3d16efedd2007d917e613a78f816baba"></a><!-- doxytag: member="RakPeer::GetIncomingPassword" ref="3d16efedd2007d917e613a78f816baba" args="(char *passwordData, int *passwordDataLength)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::GetIncomingPassword           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordDataLength</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the password passed to SetIncomingPassword <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>Should point to a block large enough to hold the password data you passed to <a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c">SetIncomingPassword()</a> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>Maximum size of the array passwordData. Modified to hold the number of bytes actually written </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#0930dfa8ac5c2e9ec184fbed97a55a4a">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="76f9b346240d1a4225bc9d85b5eb4c75"></a><!-- doxytag: member="RakPeer::GetIndexFromPlayerID" ref="76f9b346240d1a4225bc9d85b5eb4c75" args="(const PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int RakPeer::GetIndexFromPlayerID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a playerID, returns an index from 0 to the maximum number of players allowed - 1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The <a class="el" href="structPlayerID.html">PlayerID</a> we are referring to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The index of this <a class="el" href="structPlayerID.html">PlayerID</a> or -1 on system not found. </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#263b17dea74ff6fa2882a9d702767845">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#d9b40c80c3b307e764ceadab2147d346">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="588965b03942d2008a8ab40d9d06b992"></a><!-- doxytag: member="RakPeer::GetInternalID" ref="588965b03942d2008a8ab40d9d06b992" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a> RakPeer::GetInternalID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the unique address identifier that represents you on the the network and is based on your local IP / port. <dl compact><dt><b>Returns:</b></dt><dd>the identifier of your system internally, which may not be how other systems see if you if you are behind a NAT or proxy </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#a2bcd7f8896144976f23bb1a4ad8a942">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#ec5b7abd712c8ddd0c8c6b7d4a8ae22b">RakClient</a>, and <a class="el" href="classRakServer.html#447ddf571c2898d4c4aec756a8a6a392">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="933e4c272dd6801e7025bb1fd38a43ba"></a><!-- doxytag: member="RakPeer::GetLastPing" ref="933e4c272dd6801e7025bb1fd38a43ba" args="(const PlayerID playerId) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int RakPeer::GetLastPing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the last ping time read for the specific system or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The last ping time for this system, or -1 </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#ad223fa25501822d4d9d7290e53f9784">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="fe482086aeca4fe84b86ad4a40945329"></a><!-- doxytag: member="RakPeer::GetLowestPing" ref="fe482086aeca4fe84b86ad4a40945329" args="(const PlayerID playerId) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int RakPeer::GetLowestPing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the lowest ping time read or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The lowest ping time for this system, or -1 </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#7bfcb622ea726f24f901c8f34c179874">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="5c413e010504007506d6be8bc27a2668"></a><!-- doxytag: member="RakPeer::GetMaximumIncomingConnections" ref="5c413e010504007506d6be8bc27a2668" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned short RakPeer::GetMaximumIncomingConnections           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the value passed to <a class="el" href="classRakPeer.html#d2004ca40f0a88ca24f70196321d48c8">SetMaximumIncomingConnections()</a> <dl compact><dt><b>Returns:</b></dt><dd>the maximum number of incoming connections, which is always &lt;= maxConnections </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#717b4bbf42ed8f1a794158dc1e3d7a78">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="8bb37bf48b402b4b9600f4af8613fd68"></a><!-- doxytag: member="RakPeer::GetMTUSize" ref="8bb37bf48b402b4b9600f4af8613fd68" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int RakPeer::GetMTUSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current MTU size <dl compact><dt><b>Returns:</b></dt><dd>The current MTU size </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#f242a72ac32f7b76671389e03833abdd">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#e89727f08747c021920db15075a0fbb4">RakClient</a>, and <a class="el" href="classRakServer.html#c1ce293882022af8f586446bd68b5f58">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="8b3d828002aa9946b2556f657e33f0d8"></a><!-- doxytag: member="RakPeer::GetOutgoingFrequencyTable" ref="8b3d828002aa9946b2556f657e33f0d8" args="(unsigned int outputFrequencyTable[256])" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::GetOutgoingFrequencyTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>outputFrequencyTable</em>[256]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the frequency of outgoing bytes into output frequency table The purpose is to save to file as either a master frequency table from a sample game session for passing to <a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9">GenerateCompressionLayer()</a> <dl compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected. Requires that you first enable data frequency tracking by calling SetCompileFrequencyTable(true) </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outputFrequencyTable</em>&nbsp;</td><td>The frequency of each corresponding byte </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>False (failure) if connected or if frequency table tracking is not enabled. Otherwise true (success) </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#151cb8f69faadbbca6d2d0827c767544">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="661bc3f0d27aff4eaf7d3ca3136c47c7"></a><!-- doxytag: member="RakPeer::GetPlayerIDFromIndex" ref="661bc3f0d27aff4eaf7d3ca3136c47c7" args="(int index)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a> RakPeer::GetPlayerIDFromIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is only useful for looping through all systems Given an index, will return a <a class="el" href="structPlayerID.html">PlayerID</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structPlayerID.html">PlayerID</a> </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#aeebe57de2b027b93b247a39d21ba0f8">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#8dfa2dd11eb4f9fe7b6f41ee01f2f9e6">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="dacf2d7a0a3b4044e534a6c2e6cbc73e"></a><!-- doxytag: member="RakPeer::GetRemoteStaticData" ref="dacf2d7a0a3b4044e534a6c2e6cbc73e" args="(const PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> * RakPeer::GetRemoteStaticData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All systems have a block of data associated with them, for user use. This block of data can be used to easily specify typical system data that you want to know on connection, such as the player's name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which system you are referring to. Pass the value returned by GetInternalID to refer to yourself </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The data passed to SetRemoteStaticData stored as a bitstream </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#7bd6df2651746de77c732aeb508d1279">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="c9d7129b65ebc11d03bd3abb67390deb"></a><!-- doxytag: member="RakPeer::GetRemoteSystemFromPlayerID" ref="c9d7129b65ebc11d03bd3abb67390deb" args="(const PlayerID playerID, bool calledFromNetworkThread, bool onlyActive) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RakPeer::RemoteSystemStruct * RakPeer::GetRemoteSystemFromPlayerID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>calledFromNetworkThread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>onlyActive</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the reliability layer associated with a playerID. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerID</em>&nbsp;</td><td>The player identifier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if none </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2e8d282a4c8795bb3634f766d58ce5f7"></a><!-- doxytag: member="RakPeer::GetStatistics" ref="2e8d282a4c8795bb3634f766d58ce5f7" args="(const PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structRakNetStatisticsStruct.html">RakNetStatisticsStruct</a> *const RakPeer::GetStatistics           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="RakNetStatistics_8h.html#4be0bf168ff181d9508dd928769d9ca0">StatisticsToString()</a> function <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId,:</em>&nbsp;</td><td>Which connected system to get statistics for </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on can't find the specified system. A pointer to a set of data otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="RakNetStatistics_8h.html">RakNetStatistics.h</a> </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#007055e86b1d087b5fbd188ac718bb4c">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#c66b534d072afc962c2709d399b9c9c0">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="1192b8d0540c866a231d6f636d144c16"></a><!-- doxytag: member="RakPeer::HandleRPCPacket" ref="1192b8d0540c866a231d6f636d144c16" args="(const char *data, int length, PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::HandleRPCPacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Handles an RPC packet. This is sending an RPC request <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A packet returned from Receive with the ID ID_RPC </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size of the packet data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The sender of the packet </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success, false on a bad packet or an unregistered function </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2a08d04192621dae2fdeeb1668daadc6"></a><!-- doxytag: member="RakPeer::HandleRPCReplyPacket" ref="2a08d04192621dae2fdeeb1668daadc6" args="(const char *data, int length, PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::HandleRPCReplyPacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Handles an RPC reply packet. This is data returned from an RPC call <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A packet returned from Receive with the ID ID_RPC </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size of the packet data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The sender of the packet </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2c2a99cb2efb728fa814d41b2071617d"></a><!-- doxytag: member="RakPeer::Initialize" ref="2c2a99cb2efb728fa814d41b2071617d" args="(unsigned short maxConnections, unsigned short localPort, int _threadSleepTimer, const char *forceHostAddress=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::Initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>maxConnections</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>localPort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>_threadSleepTimer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>forceHostAddress</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts the network threads, opens the listen port. You must call this before calling <a class="el" href="classRakPeer.html#80e98d77e4140079634ebb284c4168f8">Connect()</a>. Multiple calls while already active are ignored. To call this function again with different settings, you must first call <a class="el" href="classRakPeer.html#44dd4adfb061e1335cef84300f758b6a">Disconnect()</a>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Call SetMaximumIncomingConnections if you want to accept incoming connections </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxConnections</em>&nbsp;</td><td>The maximum number of connections between this instance of <a class="el" href="classRakPeer.html">RakPeer</a> and another instance of <a class="el" href="classRakPeer.html">RakPeer</a>. Required so the network can preallocate and for thread safety. A pure client would set this to 1. A pure server would set it to the number of allowed clients.- A hybrid would set it to the sum of both types of connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localPort</em>&nbsp;</td><td>The port to listen for connections on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_threadSleepTimer</em>&nbsp;</td><td>How many ms to Sleep each internal update cycle (30 to give the game priority, 0 for regular (recommended), -1 to not Sleep() (may be slower)) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceHostAddress</em>&nbsp;</td><td>Can force <a class="el" href="namespaceRakNet.html">RakNet</a> to use a particular IP to host on. Pass 0 to automatically pick an IP </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>False on failure (can't create socket or thread), true on success. </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#e691380d9e0532ce99789dc5e8fc62b5">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="adcb268bdcd4751c304c8156c28eb66d"></a><!-- doxytag: member="RakPeer::InitializeSecurity" ref="adcb268bdcd4751c304c8156c28eb66d" args="(const char *pubKeyE, const char *pubKeyN, const char *privKeyP, const char *privKeyQ)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::InitializeSecurity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pubKeyE</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pubKeyN</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>privKeyP</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>privKeyQ</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Secures connections though a combination of SHA1, AES128, SYN Cookies, and RSA to prevent connection spoofing, replay attacks, data eavesdropping, packet tampering, and MitM attacks. There is a significant amount of processing and a slight amount of bandwidth overhead for this feature. If you accept connections, you must call this or else secure connections will not be enabled for incoming connections. If you are connecting to another system, you can call this with values for the (e and p,q) public keys before connecting to prevent MitM <dl compact><dt><b>Precondition:</b></dt><dd>Must be called before Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pubKeyE</em>&nbsp;</td><td>A pointer to the public keys from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pubKeyN</em>&nbsp;</td><td>A pointer to the public keys from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>privKeyP</em>&nbsp;</td><td>Public key generated from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>privKeyQ</em>&nbsp;</td><td>Public key generated from the RSACrypt class. If the private keys are 0, then a new key will be generated when this function is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>the Encryption sample </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#c7f72829da0a08298ac7cfb1486eaf22">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e360164606877bbd8df3b8c0e8b614ae"></a><!-- doxytag: member="RakPeer::IPToPlayerID" ref="e360164606877bbd8df3b8c0e8b614ae" args="(const char *host, unsigned short remotePort, PlayerID *playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::IPToPlayerID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a dotted IP to a playerId <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The result of this operation </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#c0397e6954191197a1f5cf7a8647d617">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="52ff3b23878d11d8b00473835d44b1f5"></a><!-- doxytag: member="RakPeer::IsActive" ref="52ff3b23878d11d8b00473835d44b1f5" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::IsActive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns if the network thread is running <dl compact><dt><b>Returns:</b></dt><dd>true if the network thread is running, false otherwise </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#657f140de03d2db27b4cffd3229dc107">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#95b38b22e7ea994e982841c66bfaf74c">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e1ad09ea9ca5ea8bd4a00f78e22a5abc"></a><!-- doxytag: member="RakPeer::IsBanned" ref="e1ad09ea9ca5ea8bd4a00f78e22a5abc" args="(const char *IP)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::IsBanned           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>IP</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true or false indicating if a particular IP is banned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>- Dotted IP address. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if IP matches any IPs in the ban list, accounting for any wildcards. False otherwise. </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#3aad41de0447db6585ed2657e748c836">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#b32d2eac362df10f9ce835527a8e15b4">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="972f872d20bb187a0bbb92f29d4ae34f"></a><!-- doxytag: member="RakPeer::IsNetworkSimulatorActive" ref="972f872d20bb187a0bbb92f29d4ae34f" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::IsNetworkSimulatorActive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns if you previously called ApplyNetworkSimulator <dl compact><dt><b>Returns:</b></dt><dd>If you previously called ApplyNetworkSimulator </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#0188ac9d8c95fb82d9f7e0a222b4e91f">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#f2c4a12ca44faba65bf6b90971563679">RakClient</a>, and <a class="el" href="classRakServer.html#00b1a1d4cc743e8fcb814ea959f23982">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="7b8fe9db232e77c48121ff42143d6c4c"></a><!-- doxytag: member="RakPeer::Ping" ref="7b8fe9db232e77c48121ff42143d6c4c" args="(const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::Ping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>onlyReplyOnAcceptingConnections</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a ping to the specified unconnected system. The remote system, if it is Initialized, will respond with ID_PONG. The final ping time will be encoded in the following sizeof(RakNetTime) bytes. (Default is 4 bytes - See __GET_TIME_64BIT in <a class="el" href="NetworkTypes_8h.html">NetworkTypes.h</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name. Can be 255.255.255.255 for LAN broadcast. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>onlyReplyOnAcceptingConnections</em>&nbsp;</td><td>Only request a reply if the remote system is accepting connections </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#822868ef3b4774fa0c94bd458db39412">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="0dde31855b5dde9191d5debc283315de"></a><!-- doxytag: member="RakPeer::Ping" ref="0dde31855b5dde9191d5debc283315de" args="(const PlayerID target)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::Ping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>target</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a ping to the specified connected system. <dl compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to <a class="el" href="classRakPeer.html#2c2a99cb2efb728fa814d41b2071617d">Initialize()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to ping </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#215723bb0149f360e27073d65d493143">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="49905f0c001ad4d88b802a15799d5f72"></a><!-- doxytag: member="RakPeer::PlayerIDToDottedIP" ref="49905f0c001ad4d88b802a15799d5f72" args="(const PlayerID playerId) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char * RakPeer::PlayerIDToDottedIP           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
TODO - depreciate this Returns the dotted IP address for the specified playerId <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Any player ID other than UNASSIGNED_PLAYER_ID, even if that player is not currently connected </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#29f2c16827c0e4d9237a6580789301a2">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#5636597be21663b80e0e9848373aa897">RakClient</a>.    </td>
  </tr>
</table>
<a class="anchor" name="9968ebdb31bcc7563b035a567046169b"></a><!-- doxytag: member="RakPeer::PushBackPacket" ref="9968ebdb31bcc7563b035a567046169b" args="(Packet *packet, bool pushAtHead)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::PushBackPacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>pushAtHead</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put a message back at the end of the receive queue in case you don't want to deal with it immediately <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet you want to push back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pushAtHead</em>&nbsp;</td><td>True to push the packet so that the next receive call returns it. False to push it at the end of the queue (obviously pushing it at the end makes the packets out of order) </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#e4b68058e13bb3ef247dfdee30079063">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#747db4f835dec67dd55ecda6b22074f9">RakClient</a>, and <a class="el" href="classRakServer.html#7a8835a0762d809926d1a459d9f343fd">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="30f9b6c0108bae2b860776136f6aece7"></a><!-- doxytag: member="RakPeer::Receive" ref="30f9b6c0108bae2b860776136f6aece7" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structPacket.html">Packet</a> * RakPeer::Receive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets a message from the incoming message queue. Use <a class="el" href="classRakPeer.html#f68f8d2766b45b6d951dfd62cf349a71">DeallocatePacket()</a> to deallocate the message after you are done with it. User-thread functions, such as RPC calls and the plugin function <a class="el" href="classPluginInterface.html#5966e72f872ebd754b44770ecc981bd9">PluginInterface::Update</a> occur here. <dl compact><dt><b>Returns:</b></dt><dd>0 if no packets are waiting to be handled, otherwise a pointer to a packet. sa <a class="el" href="NetworkTypes_8h.html">NetworkTypes.h</a> contains struct <a class="el" href="structPacket.html">Packet</a> </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#b92ff92041d251011bc166f6abdf119d">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#274f067ae5a89812e349e4de31d817a0">RakClient</a>, and <a class="el" href="classRakServer.html#17ee468976c887684597ee356aed13ff">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d046c7809b8889ba708bc20881845e4d"></a><!-- doxytag: member="RakPeer::RemoveFromBanList" ref="d046c7809b8889ba708bc20881845e4d" args="(const char *IP)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::RemoveFromBanList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>IP</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows a previously banned IP to connect. param[in] Dotted IP address. Can use * as a wildcard, such as 128.0.0.* will banAll IP addresses starting with 128.0.0 
<p>
Implements <a class="el" href="classRakPeerInterface.html#257193aa4581473ca2bce51207fce08e">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#7cbf788994f233299ee3741e03ac29ae">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="5f38c85967d6e57e9516c52271adc292"></a><!-- doxytag: member="RakPeer::Send" ref="5f38c85967d6e57e9516c52271adc292" args="(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::Send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a block of data to the specified system that you are connected to. Same as the above version, but takes a BitStream as input. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitStream</em>&nbsp;</td><td>The bitstream to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, what channel to order these on. Messages are only ordered relative to other messages on the same stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_PLAYER_ID to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then playerId specifies who not to send the packet to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>False if we are not connected to the specified recipient. True otherwise </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#758d4fb0ec270b415df6a557489fbbc7">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#2bddee0edbf8009ac588a080596eaa0f">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="97315733490a1f04c830d151d9dd53c0"></a><!-- doxytag: member="RakPeer::Send" ref="97315733490a1f04c830d151d9dd53c0" args="(const char *data, const int length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::Send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a block of data to the specified system that you are connected to. This function only works while the connected <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The block of data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size in bytes of the data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, what channel to order these on. Messages are only ordered relative to other messages on the same stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_PLAYER_ID to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then playerId specifies who not to send the packet to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>False if we are not connected to the specified recipient. True otherwise </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#b786713851bc4afca62742453867b8b5">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#cbe33381c408c9ae9d8965a29ffb243e">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d59d89dd83cba7de2d171b659b95a229"></a><!-- doxytag: member="RakPeer::SendStaticData" ref="d59d89dd83cba7de2d171b659b95a229" args="(const PlayerID target)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SendStaticData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>target</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends your static data to the specified system. This is automatically done on connection. You should call this when you change your static data.To send the static data of another system (such as relaying their data) you should do this normally with Send) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Who to send your static data to. Specify UNASSIGNED_PLAYER_ID to broadcast to all </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#4d04e7f38d00dbe76778402aa80d966b">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e20dde8c8397a680c70bdc9f6639ca58"></a><!-- doxytag: member="RakPeer::SetCompileFrequencyTable" ref="e20dde8c8397a680c70bdc9f6639ca58" args="(bool doCompile)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetCompileFrequencyTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>doCompile</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables or disables frequency table tracking. This is required to get a frequency table, which is used in <a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9">GenerateCompressionLayer()</a> This value persists between connect calls and defaults to false (no frequency tracking) <dl compact><dt><b>Precondition:</b></dt><dd>You can call this at any time - however you SHOULD only call it when disconnected. Otherwise you will only trackpart of the values sent over the network. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>doCompile</em>&nbsp;</td><td>True to enable tracking </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#461f51d0c7e15a6821f1252133f75d65">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6daafe75bfe4882aa46f32cb753378c"></a><!-- doxytag: member="RakPeer::SetIncomingPassword" ref="a6daafe75bfe4882aa46f32cb753378c" args="(const char *passwordData, int passwordDataLength)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetIncomingPassword           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>passwordDataLength</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the password incoming connections must match in the call to Connect (defaults to none). Pass 0 to passwordData to specify no password This is a way to set a low level password for all incoming connections. To selectively reject connections, implement your own scheme using <a class="el" href="classRakPeer.html#cc60e0732bd685a2f0216831e4cb43f3">CloseConnection()</a> to remove unwanted connections <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that incoming connections must match. This can be just a password, or can be a stream of data. Specify 0 for no password data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#6156083e485f036bc76fb1f17b249f7d">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d2004ca40f0a88ca24f70196321d48c8"></a><!-- doxytag: member="RakPeer::SetMaximumIncomingConnections" ref="d2004ca40f0a88ca24f70196321d48c8" args="(unsigned short numberAllowed)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetMaximumIncomingConnections           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>numberAllowed</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets how many incoming connections are allowed. If this is less than the number of players currently connected, no more players will be allowed to connect. If this is greater than the maximum number of peers allowed, it will be reduced to the maximum number of peers allowed. Defaults to 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberAllowed</em>&nbsp;</td><td>Maximum number of incoming connections allowed. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#43ab3da8e2a95f71f232f95a2593ba9f">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="04cfe8d6a91f892b978af2ded06dd967"></a><!-- doxytag: member="RakPeer::SetMTUSize" ref="04cfe8d6a91f892b978af2ded06dd967" args="(int size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool RakPeer::SetMTUSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the MTU per datagram. It's important to set this correctly - otherwise packets will be needlessly split, decreasing performance and throughput. Maximum allowed size is MAXIMUM_MTU_SIZE. Too high of a value will cause packets not to arrive at worst and be fragmented at best. Too low of a value will split packets unnecessarily. Recommended size is 1500 sa <a class="el" href="MTUSize_8h.html">MTUSize.h</a> <dl compact><dt><b>Precondition:</b></dt><dd>Can only be called when not connected. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>false on failure (we are connected), else true </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#2b29853e1f26929078bfcf50960e4fde">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakClient.html#728ad9d56034701883650fb81745e338">RakClient</a>, and <a class="el" href="classRakServer.html#dfb489b47c2688a30551470f9b07822a">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="8324e15260b26b92abb204ed9f04ff57"></a><!-- doxytag: member="RakPeer::SetOccasionalPing" ref="8324e15260b26b92abb204ed9f04ff57" args="(bool doPing)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetOccasionalPing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>doPing</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ping the remote systems every so often, or not. This is off by default. Can be called anytime. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>doPing</em>&nbsp;</td><td>True to start occasional pings. False to stop them. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#1eebc5c00cb8ca317aa350c90161eca6">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="7d7601d2d7114c454829c655dc9e79c7"></a><!-- doxytag: member="RakPeer::SetOfflinePingResponse" ref="7d7601d2d7114c454829c655dc9e79c7" args="(const char *data, const unsigned int length)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetOfflinePingResponse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the data to send along with a LAN server discovery or offline ping reply. <em>length</em> should be under 400 bytes, as a security measure against flood attacks <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a block of data to store, or 0 for none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of data in bytes, or 0 for none </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>Ping.cpp </dd></dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#7ccf08b2d04ef007a0719dfa4f4dadc5">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#a2ea4a4326b283e3b6924b9718a5d7f9">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="5eac39c3ad8ffd3ed232e36ae27c882f"></a><!-- doxytag: member="RakPeer::SetRemoteStaticData" ref="5eac39c3ad8ffd3ed232e36ae27c882f" args="(const PlayerID playerId, const char *data, const int length)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetRemoteStaticData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All systems have a block of data associated with them, for user use. This block of data can be used to easily specify typical system data that you want to know on connection, such as the player's name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Whose static data to change. Use your own playerId to change your own static data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a block of data to store </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of data in bytes </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#c7426d426830adea8f210261c82654a1">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="c1cb3f6aeaa842c721bbe4a3d74c3d5d"></a><!-- doxytag: member="RakPeer::SetSplitMessageProgressInterval" ref="c1cb3f6aeaa842c721bbe4a3d74c3d5d" args="(int interval)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetSplitMessageProgressInterval           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>interval</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads. ID_DOWNLOAD_PROGRESS is returned to indicate a new partial message chunk, roughly the MTU size, has arrived As it can be slow or cumbersome to get this notification for every chunk, you can set the interval at which it is returned. Defaults to 0 (never return this notification) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>How many messages to use as an interval </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#471f44e797e0cf73a8ae8ec1935ff767">RakPeerInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a30685116ddc9a1d21eef81dd1a9822f"></a><!-- doxytag: member="RakPeer::SetTimeoutTime" ref="a30685116ddc9a1d21eef81dd1a9822f" args="(RakNetTime timeMS, const PlayerID target)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetTimeoutTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RakNetTime&nbsp;</td>
          <td class="mdname" nowrap> <em>timeMS</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>target</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeMS</em>&nbsp;</td><td>Time, in MS</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to do this for </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#e159952a3af82051439634276b0a4270">RakPeerInterface</a>.
<p>
Reimplemented in <a class="el" href="classRakServer.html#3e96c807d1532314ee6710c828325a00">RakServer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="699049419ad22610064ef595cde4560e"></a><!-- doxytag: member="RakPeer::SetUnreliableTimeout" ref="699049419ad22610064ef595cde4560e" args="(RakNetTime timeoutMS)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RakPeer::SetUnreliableTimeout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RakNetTime&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timeoutMS</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set how long to wait before giving up on sending an unreliable message Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutMS</em>&nbsp;</td><td>How many ms to wait before simply not sending an unreliable message. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classRakPeerInterface.html#146669e0a5e78317b539fa22d9704df0">RakPeerInterface</a>.    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="af0f4145d68e3aab994aa58dabd8047e"></a><!-- doxytag: member="RakPeer::maximumNumberOfPeers" ref="af0f4145d68e3aab994aa58dabd8047e" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">* unsigned short <a class="el" href="classRakPeer.html#af0f4145d68e3aab994aa58dabd8047e">RakPeer::maximumNumberOfPeers</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Store the maximum number of peers allowed to connect. 
<p>
Do we occasionally ping the other systems?     </td>
  </tr>
</table>
<a class="anchor" name="fac48c9f0bb054679a435ea8eb309181"></a><!-- doxytag: member="RakPeer::remoteSystemList" ref="fac48c9f0bb054679a435ea8eb309181" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RemoteSystemStruct* <a class="el" href="classRakPeer.html#fac48c9f0bb054679a435ea8eb309181">RakPeer::remoteSystemList</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is an array of pointers to RemoteSystemStruct This allows us to preallocate the list when starting, so we don't have to allocate or delete at runtime. Another benefit is that is lets us add and remove active players simply by setting playerId and moving elements in the list by copying pointers variables without affecting running threads, even if they are in the reliability layer     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/RakNet 2.518/Include/<a class="el" href="RakPeer_8h.html">RakPeer.h</a><li>C:/RakNet 2.518/Source/<a class="el" href="RakPeer_8cpp.html">RakPeer.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Oct 14 08:37:39 2006 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
