<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: ReplicaManager Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ReplicaManager Class Reference<br>
<small>
[<a class="el" href="group__REPLICA__MANAGER__GROUP.html">ReplicaManager</a>]</small>
</h1><!-- doxytag: class="ReplicaManager" --><!-- doxytag: inherits="PluginInterface" -->A management system for your game objects and players to make serialization, scoping, and object creation and destruction easier.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ReplicaManager.h&gt;</code>
<p>
<p>Inheritance diagram for ReplicaManager:
<p><center><img src="classReplicaManager.png" usemap="#ReplicaManager_map" border="0" alt=""></center>
<map name="ReplicaManager_map">
<area href="classPluginInterface.html" alt="PluginInterface" shape="rect" coords="0,0,105,24">
</map>
<a href="classReplicaManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<b>REPLICA_EXPLICIT_CONSTRUCTION</b> = 1&lt;&lt;0, 
<b>REPLICA_IMPLICIT_CONSTRUCTION</b> = 1&lt;&lt;1, 
<b>REPLICA_SCOPE_TRUE</b> = 1&lt;&lt;2, 
<b>REPLICA_SCOPE_FALSE</b> = 1&lt;&lt;3, 
<br>
&nbsp;&nbsp;<b>REPLICA_SERIALIZE</b> = 1&lt;&lt;4
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a699a030dde190e8f6a1fecbd83cb0e"></a><!-- doxytag: member="ReplicaManager::ReplicaManager" ref="8a699a030dde190e8f6a1fecbd83cb0e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#8a699a030dde190e8f6a1fecbd83cb0e">ReplicaManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d115c72f9422d93f500e8fe5a290d5b"></a><!-- doxytag: member="ReplicaManager::~ReplicaManager" ref="5d115c72f9422d93f500e8fe5a290d5b" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5d115c72f9422d93f500e8fe5a290d5b">~ReplicaManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#cfd1be4e145f3f11d02ee866fc5e737f">SetAutoParticipateNewConnections</a> (bool autoAdd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#fb1de29265a6c33d92d9953444432864">AddParticipant</a> (<a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#7089fedb7bf9f0f54edb7896b315388c">RemoveParticipant</a> (<a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#30a77ed0b846961ff0c8e37d07a9aa99">Construct</a> (<a class="el" href="classReplica.html">Replica</a> *replica, bool isCopy, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#a01b1fbe885dcedb6af0d0178cad9264">Destruct</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#083f4f17ab6924a5d3a6581b1093bcac">ReferencePointer</a> (<a class="el" href="classReplica.html">Replica</a> *replica)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#f14904b4d245d7202a1ab7c41a909a4c">DereferencePointer</a> (<a class="el" href="classReplica.html">Replica</a> *replica)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5f55a9efabdb5cfd2a1fdd437dc283e2">SetScope</a> (<a class="el" href="classReplica.html">Replica</a> *replica, bool inScope, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#8039cad3a0cd1c38b9e18484147ddabc">SignalSerializeNeeded</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structPlayerID.html">PlayerID</a> playerId, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#b455a94ef73a81e772afdb9bc820974b">SetReceiveConstructionCB</a> (<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*constructionCB)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, RakNetTime timestamp, NetworkID networkID, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#ba30ad032ff8e624d6cc652eb5fb713a">SetDownloadCompleteCB</a> (<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*sendDownloadCompleteCB)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, RakNetTime currentTime, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller), <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*receiveDownloadCompleteCB)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#1b21ec1b0f07c7bce29600db7cbada96">SetSendChannel</a> (unsigned char channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#0549b1458909abc29a0396e63b5a4868">SetAutoConstructToNewParticipants</a> (bool autoConstruct)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#011ed89662e5aacbf30aeb6e7b4fdcd9">SetDefaultScope</a> (bool scope)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5658bc1437932f065a27ec4d61017424">EnableReplicaInterfaces</a> (<a class="el" href="classReplica.html">Replica</a> *replica, unsigned char interfaceFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5201542199e51922dd53c4f0249dc86a">DisableReplicaInterfaces</a> (<a class="el" href="classReplica.html">Replica</a> *replica, unsigned char interfaceFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#0caad45c5ac0ff413f79b2194e1c3a07">IsConstructed</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#3f3d04ae917b83c2ead351476da1e962">IsInScope</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#7a307b91ce71e0fa08bbea32760532ef">GetReplicaAtIndex</a> (unsigned index)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a4cbca22448781b6340ad40c7d04cab"></a><!-- doxytag: member="ReplicaManager::RegisteredReplicaComp" ref="4a4cbca22448781b6340ad40c7d04cab" args="(Replica *const &amp;key, const ReplicaManager::RegisteredReplica &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisteredReplicaComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::RegisteredReplica &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba5fd98c057e6b0ca4381490d8c11ef4"></a><!-- doxytag: member="ReplicaManager::RemoteObjectComp" ref="ba5fd98c057e6b0ca4381490d8c11ef4" args="(Replica *const &amp;key, const ReplicaManager::RemoteObject &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoteObjectComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::RemoteObject &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d79d7a457d712d262ed70cddc9270d0"></a><!-- doxytag: member="ReplicaManager::CommandStructComp" ref="3d79d7a457d712d262ed70cddc9270d0" args="(Replica *const &amp;key, const ReplicaManager::CommandStruct &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandStructComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::CommandStruct &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="858a35f6a619e84fcc768fcba35ef0fc"></a><!-- doxytag: member="ReplicaManager::ParticipantStructComp" ref="858a35f6a619e84fcc768fcba35ef0fc" args="(const PlayerID &amp;key, ReplicaManager::ParticipantStruct *const &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ParticipantStructComp</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> &amp;key, ReplicaManager::ParticipantStruct *const &amp;data)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6545f9a24d8086e738bc8ec4c56d17d3"></a><!-- doxytag: member="ReplicaManager::Clear" ref="6545f9a24d8086e738bc8ec4c56d17d3" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#6545f9a24d8086e738bc8ec4c56d17d3">Clear</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all memory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f67c84ca14d99a1f5e7e5d2439ad68f5"></a><!-- doxytag: member="ReplicaManager::ProcessReceivedCommand" ref="f67c84ca14d99a1f5e7e5d2439ad68f5" args="(ParticipantStruct *participantStruct, ReceivedCommand *receivedCommand)" -->
<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ProcessReceivedCommand</b> (ParticipantStruct *participantStruct, ReceivedCommand *receivedCommand)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#35dfe3841d8cfc5b78174f11251acac6">Update</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#41deec3843e868c185b946091694843f">OnAttach</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PluginReceiveResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#ad65d9a5c4de623dc1e17f8ef3b44fd8">OnReceive</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structPacket.html">Packet</a> *packet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#ade925c0f34f8b68c11286c9205e85a2">OnCloseConnection</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structPlayerID.html">PlayerID</a> playerId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#faf1eb4a2496cffe44bbc487e90060b2">OnDisconnect</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f39e61d51d55cadfd082e29943490651"></a><!-- doxytag: member="ReplicaManager::GetParticipantByPlayerID" ref="f39e61d51d55cadfd082e29943490651" args="(const PlayerID playerId) const " -->
ParticipantStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParticipantByPlayerID</b> (const <a class="el" href="structPlayerID.html">PlayerID</a> playerId) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<br>
 <a class="el" href="classReplica.html">Replica</a> *, RegisteredReplica,<br>
 ReplicaManager::RegisteredReplicaComp &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#157a22e5a3ae38376d11cd7da7bd249e">replicatedObjects</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<br>
 <a class="el" href="structPlayerID.html">PlayerID</a>, ParticipantStruct *,<br>
 ReplicaManager::ParticipantStructComp &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#7ac60701167b1728cfeb539c8ae96842">participantList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8aa5b10567668eb4323d51a288a2004"></a><!-- doxytag: member="ReplicaManager::_constructionCB" ref="a8aa5b10567668eb4323d51a288a2004" args=")(RakNet::BitStream *inBitStream, RakNetTime timestamp, NetworkID networkID, PlayerID senderId, ReplicaManager *caller)" -->
<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>_constructionCB</b> )(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, RakNetTime timestamp, NetworkID networkID, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="096402e7e00ac99f014c1a470b838972"></a><!-- doxytag: member="ReplicaManager::_sendDownloadCompleteCB" ref="096402e7e00ac99f014c1a470b838972" args=")(RakNet::BitStream *outBitStream, RakNetTime currentTime, PlayerID senderId, ReplicaManager *caller)" -->
<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sendDownloadCompleteCB</b> )(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, RakNetTime currentTime, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5247d0649c2fb809b53b9abfe41281fc"></a><!-- doxytag: member="ReplicaManager::_receiveDownloadCompleteCB" ref="5247d0649c2fb809b53b9abfe41281fc" args=")(RakNet::BitStream *inBitStream, PlayerID senderId, ReplicaManager *caller)" -->
<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>_receiveDownloadCompleteCB</b> )(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73ee075ec3957ffb20efa1c150d595fa"></a><!-- doxytag: member="ReplicaManager::sendChannel" ref="73ee075ec3957ffb20efa1c150d595fa" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>sendChannel</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="036f4fa0fc0cad2a3b4fd3e3a0933a2d"></a><!-- doxytag: member="ReplicaManager::autoParticipateNewConnections" ref="036f4fa0fc0cad2a3b4fd3e3a0933a2d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>autoParticipateNewConnections</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1f5c5711d9c134b78ebc613252610c4"></a><!-- doxytag: member="ReplicaManager::defaultScope" ref="e1f5c5711d9c134b78ebc613252610c4" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>defaultScope</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c4bc10be5b05b2f5a2e182f33f13aaa"></a><!-- doxytag: member="ReplicaManager::autoConstructToNewParticipants" ref="3c4bc10be5b05b2f5a2e182f33f13aaa" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>autoConstructToNewParticipants</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ef6e1a5408b2606665e956e775640de"></a><!-- doxytag: member="ReplicaManager::rakPeer" ref="6ef6e1a5408b2606665e956e775640de" args="" -->
<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>rakPeer</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ParticipantStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ReceivedCommand</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisteredReplica</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoteObject</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A management system for your game objects and players to make serialization, scoping, and object creation and destruction easier. 
<p>
<a class="el" href="classReplicaManager.html">ReplicaManager</a> is a system manager for your game objects that performs the following tasks: 1. Tracks all locally registered game objects and players and only performs operations to and for those objects and players 2. Allows you to automatically turn off unneeded local and remote functions for your game objects, thus providing convenience and security against unauthorized sends. 3. Sends notifications of existing game objects to new connections, including a download complete message. 4. Sends notifications of new game objects to existing players. A. Serialize and scoping calls are not sent to objects that were not notified of that object. B. Notification calls can be cancelled on a per-object basis. Object notification sends are tracked on a per-system per-object basis. 5. Configurable per-system per-object scoping. A. Scoping provides a mechanism to hide and unhide remote objects without destroying the whole object, used when when entities should not be destroyed but are currently not visible to systems. B. Serialize calls are not sent to hidden objects. C. Scoping calls can be cancelled on a per-object basis. Scope is tracked on a per-system per-object basis. 6. Replicate, SetScope, SignalSerializeNeeded, and the corresponding <a class="el" href="classReplica.html">Replica</a> interfaces are processed in <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">RakPeer::Receive</a>, rather than immediately. A. This allows the <a class="el" href="classReplicaManager.html">ReplicaManager</a> to reorganize function calls in order by dependency. This allows out of order calls, per-object call cancellation (which also cancels dependencies), and per-object call delays (which also delays dependencies) B. For example, although SetScope and SignalSerializeNeeded have a dependency on SetNetworkID(), you can still call them in the constructor and call SetNetworkID() later, as long as it happens before calling <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">RakPeer::Receive()</a> 7. The system is fast, uses little memory, and is intentionally hands off such that it can work with any game architecture and network topology<p>
What the <a class="el" href="classReplicaManager.html">ReplicaManager</a> system does NOT do for you 1. Actually create or destroy your game objects 2. Associate object destruction events with remote system disconnects. 3. Set networkIDs via SetNetworkID() on newly created objects. 4. Object sub-serialization. Serialize only granular on the level of entire objects. If you want to serialize part of the object, you need to set your own flags and indicate in the BitStream which parts were sent and which not. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fb1de29265a6c33d92d9953444432864"></a><!-- doxytag: member="ReplicaManager::AddParticipant" ref="fb1de29265a6c33d92d9953444432864" args="(PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::AddParticipant           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a participant to the <a class="el" href="classReplicaManager.html">ReplicaManager</a> system. Only these participants get packets and we only accept <a class="el" href="classReplicaManager.html">ReplicaManager</a> packets from these participants. This way you can have connections that have nothing to do with your game - for example remote console logins <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which player you are referring to </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="30a77ed0b846961ff0c8e37d07a9aa99"></a><!-- doxytag: member="ReplicaManager::Construct" ref="30a77ed0b846961ff0c8e37d07a9aa99" args="(Replica *replica, bool isCopy, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::Construct           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>isCopy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct the specified object on the specified system <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> will be called on the next update cycle for the player you specify Nothing is actually created - this just signals that another system wants you to do so. The other system will get Replica::ReceiveConstruction If your system assigns NetworkIDs, do so before calling Replicate as the NetworkID is automatically included in the packet. Replicate packets that are sent to systems that already have this NetworkID are ignored. <dl compact><dt><b>Note:</b></dt><dd>Objects which are replicated get exactly one call to SendConstruction for every player / object permutation. <p>
To perform scoping and serialize updates on an object already created by another system, call Construct with <em>isCopy</em> true. <p>
Setting <em>isCopy</em> true will consider the object created on that system without actually trying to create it. <p>
If you don't need to send updates to other systems for this object, it is more efficient to use ReferencePointer instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isCopy</em>&nbsp;</td><td>True means that this is a copy of an object that already exists on the systems specified by <em>playerId</em> and <em>broadcast</em>. If true, we will consider these systems as having the object without sending a datagram to them. SendConstruction will NOT be called for objects which <em>isCopy</em> is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If playerId!=UNASSIGNED_PLAYER_ID then this means send to all but that participant </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f14904b4d245d7202a1ab7c41a909a4c"></a><!-- doxytag: member="ReplicaManager::DereferencePointer" ref="f14904b4d245d7202a1ab7c41a909a4c" args="(Replica *replica)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::DereferencePointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>replica</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this before you delete <em>replica</em>. This locally removes all references to this pointer. No messages are sent. Best place to put this is in the destructor of <em>replica</em> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a01b1fbe885dcedb6af0d0178cad9264"></a><!-- doxytag: member="ReplicaManager::Destruct" ref="a01b1fbe885dcedb6af0d0178cad9264" args="(Replica *replica, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::Destruct           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this with your game objects to have them send <a class="el" href="classReplica.html#6d358534e48bc375405213ad8ce13294">Replica::SendDestruction</a>. This will be sent immediately to all participants that have this object. Those participants will get <a class="el" href="classReplica.html#2e8e75dc7d04ff19a586275fb52627bc">Replica::ReceiveDestruction</a> All pending calls for this object, for this player, are canceled. Nothing is actually deleted - this just signals that the other system called this function. It is up to you to actually delete your object. <dl compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, SetNetworkID on that object must have been called with the same value as GetNetworkID for this object. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Call Destruct before DereferencePointer if you plan on calling both, since Destruct will fail with no pointer reference. <p>
Calling Destruct with playerId==UNASSIGNED_PLAYER_ID and broadcast true is equivalent to calling DereferencePointer except that Destruct also sends the destruct packet. <p>
It is important to call this before deleting your object. Otherwise this system will crash the next Update call. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If playerId!=UNASSIGNED_PLAYER_ID then this means send to all but that participant </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5201542199e51922dd53c4f0249dc86a"></a><!-- doxytag: member="ReplicaManager::DisableReplicaInterfaces" ref="5201542199e51922dd53c4f0249dc86a" args="(Replica *replica, unsigned char interfaceFlags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::DisableReplicaInterfaces           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>interfaceFlags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lets you disable calling any or all of the interface functions in an instance of <a class="el" href="classReplica.html">Replica</a> This setting is the same for all participants for this object, so if you want per-participant permissions you will need to handle that inside your implementation All functions enabled by default. <dl compact><dt><b>Note:</b></dt><dd>Disabling functions is very useful for security. <p>
For example, on the server you may wish to disable all receive functions so clients cannot change server objects. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object you are referring to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interfaceFlags</em>&nbsp;</td><td>A bitwise-OR of REPLICA_SEND_CONSTRUCTION ... REPLICA_SET_ALL corresponding to the function of the same name </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5658bc1437932f065a27ec4d61017424"></a><!-- doxytag: member="ReplicaManager::EnableReplicaInterfaces" ref="5658bc1437932f065a27ec4d61017424" args="(Replica *replica, unsigned char interfaceFlags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::EnableReplicaInterfaces           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>interfaceFlags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lets you enable calling any or all of the interface functions in an instance of <a class="el" href="classReplica.html">Replica</a> This setting is the same for all participants for this object, so if you want per-participant permissions you will need to handle that inside your implementation All functions enabled by default. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object you are referring to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interfaceFlags</em>&nbsp;</td><td>A bitwise-OR of REPLICA_SEND_CONSTRUCTION ... REPLICA_SET_ALL corresponding to the function of the same name </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7a307b91ce71e0fa08bbea32760532ef"></a><!-- doxytag: member="ReplicaManager::GetReplicaAtIndex" ref="7a307b91ce71e0fa08bbea32760532ef" args="(unsigned index)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> * ReplicaManager::GetReplicaAtIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a previously registered <a class="el" href="classReplica.html">Replica</a> *, from index 0 to <a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount()</a>-1. The order that <a class="el" href="classReplica.html">Replica</a> * objects are returned in is arbitrary (it currently happens to be ordered by pointer address). Calling Dereplicate immediately deletes the <a class="el" href="classReplica.html">Replica</a> * passed to it, so if you call Dereplicate while using this function the array will be shifted over and the current index will now reference the next object in the array, if there was one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>An index, from 0 to <a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount()</a>-1. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classReplica.html">Replica</a> * previously passed to <a class="el" href="classReplicaManager.html#30a77ed0b846961ff0c8e37d07a9aa99">Construct()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="99b46ca5a05affea7b783d08c0c962da"></a><!-- doxytag: member="ReplicaManager::GetReplicaCount" ref="99b46ca5a05affea7b783d08c0c962da" args="(void) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned ReplicaManager::GetReplicaCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns how many <a class="el" href="classReplica.html">Replica</a> instances are registered. This number goes up with each non-duplicate call to Replicate and down with each non-duplicate call to Dereplicate Used for GetReplicaAtIndex if you want to perform some object on all registered <a class="el" href="classReplica.html">Replica</a> objects. <dl compact><dt><b>Returns:</b></dt><dd>How many replica objects are in the list of replica objects </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0caad45c5ac0ff413f79b2194e1c3a07"></a><!-- doxytag: member="ReplicaManager::IsConstructed" ref="0caad45c5ac0ff413f79b2194e1c3a07" args="(Replica *replica, PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ReplicaManager::IsConstructed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells us if a particular system got a SendConstruction() message from this object. e.g. does this object exist on this remote system? This is set by the user when calling Replicate and sending (any) data to outBitStream in <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object we are checking </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The system we are checking </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3f3d04ae917b83c2ead351476da1e962"></a><!-- doxytag: member="ReplicaManager::IsInScope" ref="3f3d04ae917b83c2ead351476da1e962" args="(Replica *replica, PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ReplicaManager::IsInScope           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells us if a particular object is in scope for a particular system This is set by the user when calling SetScope and sending (any) data to outBitstream in <a class="el" href="classReplica.html#5a7fc15910e729e4c30fcb8a29c4374f">Replica::SendScopeChange</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object we are checking </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The system we are checking </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="41deec3843e868c185b946091694843f"></a><!-- doxytag: member="ReplicaManager::OnAttach" ref="41deec3843e868c185b946091694843f" args="(RakPeerInterface *peer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::OnAttach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>peer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called when the interface is attached <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#9124155ea27bf6c50801350d21173d68">PluginInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="ade925c0f34f8b68c11286c9205e85a2"></a><!-- doxytag: member="ReplicaManager::OnCloseConnection" ref="ade925c0f34f8b68c11286c9205e85a2" args="(RakPeerInterface *peer, PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::OnCloseConnection           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called when a connection is dropped because the user called <a class="el" href="classRakPeer.html#cc60e0732bd685a2f0216831e4cb43f3">RakPeer::CloseConnection()</a> for a particular system <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The system whose connection was closed </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#b38aba2426aa9c6e0b5371f5fa9f942e">PluginInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="faf1eb4a2496cffe44bbc487e90060b2"></a><!-- doxytag: member="ReplicaManager::OnDisconnect" ref="faf1eb4a2496cffe44bbc487e90060b2" args="(RakPeerInterface *peer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::OnDisconnect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>peer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called when <a class="el" href="classRakPeer.html">RakPeer</a> is shutdown <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#fc53d0d07b6714fcaeb7e18ed3fa83a1">PluginInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="ad65d9a5c4de623dc1e17f8ef3b44fd8"></a><!-- doxytag: member="ReplicaManager::OnReceive" ref="ad65d9a5c4de623dc1e17f8ef3b44fd8" args="(RakPeerInterface *peer, Packet *packet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">PluginReceiveResult ReplicaManager::OnReceive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>packet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
OnReceive is called for every packet. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>the packet that is being returned to the user </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True to allow the game and other plugins to get this message, false to absorb it </dd></dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#633dcfc264e4309c41f0cfeb84b4840a">PluginInterface</a>.    </td>
  </tr>
</table>
<a class="anchor" name="083f4f17ab6924a5d3a6581b1093bcac"></a><!-- doxytag: member="ReplicaManager::ReferencePointer" ref="083f4f17ab6924a5d3a6581b1093bcac" args="(Replica *replica)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::ReferencePointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>replica</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This makes sure the object is tracked, so you can get calls on it. This will automatically happen if you call Construct, SetScope, or SignalSerializeNeeded with <em>replica</em> Otherwise you need to call this, or for security the system will ignore calls that reference this object, even if given a valid NetworkID Duplicate calls are safe and are simply ignored. Best place to put this is in the SetReceiveConstructionCB callback so that all your objects are registered. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7089fedb7bf9f0f54edb7896b315388c"></a><!-- doxytag: member="ReplicaManager::RemoveParticipant" ref="7089fedb7bf9f0f54edb7896b315388c" args="(PlayerID playerId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::RemoveParticipant           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>playerId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes a participant from the data replicator system This is called automatically on ID_DISCONNECTION_NOTIFICATION and ID_CONNECTION_LOST messages, as well as CloseConnection() calls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>Which player you are referring to </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0549b1458909abc29a0396e63b5a4868"></a><!-- doxytag: member="ReplicaManager::SetAutoConstructToNewParticipants" ref="0549b1458909abc29a0396e63b5a4868" args="(bool autoConstruct)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetAutoConstructToNewParticipants           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>autoConstruct</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This means automatically construct all known objects to all new participants Has no effect on existing participants Useful if your architecture always has all objects constructed on all systems all the time anyway, or if you want them to normally start constructed Defaults to false. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoConstruct</em>&nbsp;</td><td>true or false, as desired. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="cfd1be4e145f3f11d02ee866fc5e737f"></a><!-- doxytag: member="ReplicaManager::SetAutoParticipateNewConnections" ref="cfd1be4e145f3f11d02ee866fc5e737f" args="(bool autoAdd)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetAutoParticipateNewConnections           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>autoAdd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do or don't automatically call AddParticipant when new systems connect to us. Won't add automatically add connections that already exist before this was called Defaults to false <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoAdd</em>&nbsp;</td><td>True or false, to add or not </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="011ed89662e5aacbf30aeb6e7b4fdcd9"></a><!-- doxytag: member="ReplicaManager::SetDefaultScope" ref="011ed89662e5aacbf30aeb6e7b4fdcd9" args="(bool scope)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetDefaultScope           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>scope</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the default scope for new objects to all players. Defaults to false, which means Serialize will not be called for new objects automatically. If you set this to true, then new players will get existing objects, and new objects will be sent to existing players This only applies to players that connect and objects that are replicated after this call. Existing object scopes are not affected. Useful to set to true if you don't use scope, or if all objects normally start in scope <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scope</em>&nbsp;</td><td>The default scope to use. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ba30ad032ff8e624d6cc652eb5fb713a"></a><!-- doxytag: member="ReplicaManager::SetDownloadCompleteCB" ref="ba30ad032ff8e624d6cc652eb5fb713a" args="(ReplicaReturnResult(*sendDownloadCompleteCB)(RakNet::BitStream *outBitStream, RakNetTime currentTime, PlayerID senderId, ReplicaManager *caller), ReplicaReturnResult(*receiveDownloadCompleteCB)(RakNet::BitStream *inBitStream, PlayerID senderId, ReplicaManager *caller))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetDownloadCompleteCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, RakNetTime currentTime, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)&nbsp;</td>
          <td class="mdname" nowrap> <em>sendDownloadCompleteCB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)&nbsp;</td>
          <td class="mdname" nowrap> <em>receiveDownloadCompleteCB</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inBitStream</em>&nbsp;</td><td>The bitstream that was written to in the sendDownloadCompleteCB callback</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b455a94ef73a81e772afdb9bc820974b"></a><!-- doxytag: member="ReplicaManager::SetReceiveConstructionCB" ref="b455a94ef73a81e772afdb9bc820974b" args="(ReplicaReturnResult(*constructionCB)(RakNet::BitStream *inBitStream, RakNetTime timestamp, NetworkID networkID, PlayerID senderId, ReplicaManager *caller))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetReceiveConstructionCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>(*)(<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, RakNetTime timestamp, NetworkID networkID, <a class="el" href="structPlayerID.html">PlayerID</a> senderId, <a class="el" href="classReplicaManager.html">ReplicaManager</a> *caller)&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>constructionCB</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Required callback Set your callback to parse requests to create new objects. Specifically, when <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> is called and the networkID of the object is either unset or can't be found, this callback will get that call. How do you know what object to create? It's up to you, but I suggest in <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> you encode the class name. The best way to do this is with the <a class="el" href="classStringTable.html">StringTable</a> class. <dl compact><dt><b>Note:</b></dt><dd>If you return true from IsNetworkIDAuthority, which you should do for a server or peer, I recommend also encoding the value returned by GetNetworkID() within <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> into that bitstream and reading it here. Then set that value in a call to SetNetworkID. Dereplicate, SetScope, and SignalSerializeNeeded all rely on being able to call GET_OBJECT_FROM_ID which requires that SetNetworkID be called on that object. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constructionCB</em>&nbsp;</td><td>The callback function pointer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inBitStream</em>&nbsp;</td><td>The bitstream that was written to in <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If in <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> you set sendTimestamp to true, this is the time the packet was sent. Otherwise it is 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>If the remote object had an NetworkID set by the time <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> was called it is here. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>senderId</em>&nbsp;</td><td>Which <a class="el" href="structPlayerID.html">PlayerID</a> sent this packet. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5f55a9efabdb5cfd2a1fdd437dc283e2"></a><!-- doxytag: member="ReplicaManager::SetScope" ref="5f55a9efabdb5cfd2a1fdd437dc283e2" args="(Replica *replica, bool inScope, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetScope           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>inScope</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the scope of your object in relation to another participant. Objects that are in-scope for that participant will send out <a class="el" href="classReplica.html#c0c4114fc8ad3bf23876b18a29c7ec8d">Replica::Serialize</a> calls. Otherwise Serialize calls are not sent. Scoping is useful when you want to disable sends to an object temporarily, without deleting that object. Calling this results in <a class="el" href="classReplica.html#5a7fc15910e729e4c30fcb8a29c4374f">Replica::SendScopeChange</a> being called on the local object and <a class="el" href="classReplica.html#bab013f873f1f535132c3616d25bc596">Replica::ReceiveScopeChange</a> on the remote object if that object has been created on that remote system. Your game should ensure that objects not in scope are hidden, but not deallocated, on the remote system. <a class="el" href="classReplica.html#5a7fc15910e729e4c30fcb8a29c4374f">Replica::SendScopeChange</a> with <em>inScope</em> as true will automatically perform <a class="el" href="classReplica.html#c0c4114fc8ad3bf23876b18a29c7ec8d">Replica::Serialize</a> <dl compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, that object must have an NetworkID (set by SetNetworkID()) the same as our object's NetworkID (returned from GetNetworkID()). </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>You can set the default scope with <a class="el" href="classReplicaManager.html#011ed89662e5aacbf30aeb6e7b4fdcd9">SetDefaultScope()</a> <p>
Individual objects can refuse to perform the SendScopeChange call by not writing to the output bitstream while returning true. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inScope</em>&nbsp;</td><td>in scope or not. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If playerId!=UNASSIGNED_PLAYER_ID then this means send to all but that participant </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1b21ec1b0f07c7bce29600db7cbada96"></a><!-- doxytag: member="ReplicaManager::SetSendChannel" ref="1b21ec1b0f07c7bce29600db7cbada96" args="(unsigned char channel)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SetSendChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned char&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>channel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This channel will be used for all <a class="el" href="classRakPeer.html#97315733490a1f04c830d151d9dd53c0">RakPeer::Send</a> calls <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to use for internal <a class="el" href="classRakPeer.html#97315733490a1f04c830d151d9dd53c0">RakPeer::Send</a> calls from this system. Defaults to 0. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8039cad3a0cd1c38b9e18484147ddabc"></a><!-- doxytag: member="ReplicaManager::SignalSerializeNeeded" ref="8039cad3a0cd1c38b9e18484147ddabc" args="(Replica *replica, PlayerID playerId, bool broadcast)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::SignalSerializeNeeded           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structPlayerID.html">PlayerID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>playerId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>broadcast</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal that data has changed and we need to call Serialize() on the <em>replica</em> object. This will happen if the object has been registered, <a class="el" href="classReplica.html#63b7f1fe14463e081bdb3c33b60f7349">Replica::SendConstruction</a> wrote to outBitStream and returned true, and the object is in scope for this player. <dl compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, that object must have an NetworkID (set by SetNetworkID()) the same as our object's NetworkID (returned from GetNetworkID()). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>playerId</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If playerId!=UNASSIGNED_PLAYER_ID then this means send to all but that participant </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="35dfe3841d8cfc5b78174f11251acac6"></a><!-- doxytag: member="ReplicaManager::Update" ref="35dfe3841d8cfc5b78174f11251acac6" args="(RakPeerInterface *peer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReplicaManager::Update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>peer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update is called every time a packet is checked for . <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>- the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#5966e72f872ebd754b44770ecc981bd9">PluginInterface</a>.    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7ac60701167b1728cfeb539c8ae96842"></a><!-- doxytag: member="ReplicaManager::participantList" ref="7ac60701167b1728cfeb539c8ae96842" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<a class="el" href="structPlayerID.html">PlayerID</a>, ParticipantStruct *, ReplicaManager::ParticipantStructComp&gt; <a class="el" href="classReplicaManager.html#7ac60701167b1728cfeb539c8ae96842">ReplicaManager::participantList</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
List of participants Each participant has several queues of pending commands Sorted by playerID The only complexity is that each participant also needs a list of objects that mirror the variable replicatedObjects so we know per-player if that object is in scope     </td>
  </tr>
</table>
<a class="anchor" name="157a22e5a3ae38376d11cd7da7bd249e"></a><!-- doxytag: member="ReplicaManager::replicatedObjects" ref="157a22e5a3ae38376d11cd7da7bd249e" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<a class="el" href="classReplica.html">Replica</a> *, RegisteredReplica, ReplicaManager::RegisteredReplicaComp&gt; <a class="el" href="classReplicaManager.html#157a22e5a3ae38376d11cd7da7bd249e">ReplicaManager::replicatedObjects</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
List of objects replicated in the Replicate function. Used to make sure queued actions happen on valid pointers, since objects are removed from the list in Dereplicate Sorted by raw pointer address using the default sort     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/RakNet 2.518/Include/<a class="el" href="ReplicaManager_8h.html">ReplicaManager.h</a><li>C:/RakNet 2.518/Source/ReplicaManager.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Oct 14 08:37:39 2006 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
